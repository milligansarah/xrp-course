{
    "Lesson 6 - OOP Deep Dive Part 1": {
        "Introduction": {
            "0": {
                "actionType": "Read",
                "content": "<p> \nYou’ve already learned a lot about programming in the first five lessons, but there’s also been a \nhand-waving of concepts by saying “ignore this for now, we’ll learn about it later”. This has enabled you \nto spend more time focusing on writing code and playing with the robot. However, it can also feel a little \noverwhelming when you’re looking at a lot code that you don’t fully understand. Similar to what we did \nin lesson four with methods, this lesson is going to focus on helping you build a deeper understanding of \nobject-oriented programming and what classes and objects are. These are some of the fundamentally \nmost important concepts in Java and many other programming languages, so take your time with this \nlesson, focus, repeat the reading and/or videos as necessary, and don’t worry if it seems overwhelming \nat first. If you go through the material and projects carefully, you will come to understand it, and that \nwill help you understand what’s going on in the robot code much better as well. For the hands-on \nportion of this project, first you’ll follow along with a video, and then you’ll modify the Romi code to use \ntwo of the built-in LEDs – red and green – to indicate whether or not the Romi has been rotated from its \noriginal orientation (for example, if you were to drive it and it started to veer off course instead of \ndriving straight ahead.) \n</p>"
            },
            "1": {
                "actionType": "Code",
                "content": "<p> \nStart out by watching this video and following along in a blank non-robot project in VSCode. If \nyou don’t remember how to set up a non-robot project in VSCode, you can refer back to lesson 4. This \nvideo gives a simple explanation of objects, how they have methods and variables, and how you can use \nthem: https://www.youtube.com/watch?v=0NPR8GFHNmE \n</p>"
            },
            "2": {
                "actionType": "Code",
                "content": "<p> \nAfter you watch the video and code along with it, read this page, from the start through section \n2.9. Don’t worry about anything that comes after section 2.9: \nhttps://www3.ntu.edu.sg/home/ehchua/programming/java/J3a_OOPBasics.html \n</p>"
            },
            "3": {
                "actionType": "Read",
                "content": "<p>Now that you’ve made your way through these materials, you should have a decent idea of \nwhat object-oriented programming (OOP) is, and robot code will probably make a little more sense to \nyou. There are still a lot of concepts to cover in part two, but you’ve done enough reading for one lesson \nso let’s get our hands dirty with some Romi code. \n</p>"
            }
        },
        "Measuring Orientation: Gyroscopes": {
            "4": {
                "actionType": "Read",
                "content": "<p>The Romi has a built-in gyroscope, or gyro, which is a device that measures changes in \norientation of the robot and can also add up all the changes over time to measure the current \norientation at any given moment. Having access to this data opens up a lot of possibilities when it comes \nto robot code. One example of this is the autonomous program you saw run in the very first lesson, \nwhere the Romi turns around twice. How does it know how much to turn, to turn around without \nturning too far (or not far enough)? While this could be achieved by measuring exactly how far each \nwheel spins, the most reliable way to do this is to use the gyro, because, for example, the wheel could \nslip. Another great use of a gyro is detecting whether or not your robot is driving straight, because there \nare a lot of ways your robot could drive a bit crooked. One motor might be slightly more powerful than \nthe other. One side of the drivetrain might have more mechanical resistance than the other. The surface \nyou’re driving on might be a little bit uneven. Those are just a few examples; there are a lot of things \nthat can go wrong, but with a gyro, you can detect all these things, and correct for them. In a future \nlesson we’ll correct for them, but today we’ll just worry about detecting them. We’ll write a program \nthat uses the built-in lights to light up either red or green, based on whether or not the Romi is still \nfacing the same direction it was when the program started running. \n</p>"
            }
        },
        "Accessing Class Data": {
            "5": {
                "actionType": "Code",
                "content": "<div><p>To do this project, we’re going to need to access a few variables that, by default, we can’t \naccess. We’ll talk more about this in the second part of the object-oriented programming deep dive, \nnext lesson. There are reasons why these variables should not be accessible to us, but for this project, \nwe’re going to make them accessible anyway. Follow these steps to get everything setup for this project: \n</p><li>1. Create a new RomiReference project like you’ve done a couple times already.</li><li>2. In RobotContainer.java on line 31, there are two instances of the word “INPUT”. Change these both to “OUTPUT”. This tells the Romi to use the red and green LED lights as output. \n</li><li>3. In Drivetrain.java on line 32, change the first word of the line, “private”, to “public”.</li></ol></div>"
            },
            "6": {
                "actionType": "Code",
                "content": "<p>With that out of the way, it’s time to get started. This program will utilize your newly gained \nknowledge about classes by accessing variables belonging to various objects in the program. In this \nproject, we’re going to create an interaction between two subsystems: the drivetrain, which is where \nthe gyro exists, and the on-board IO, which is where the lights exist. Go to OnBoardIO.java and create a \nclass field for a Drivetrain object. We’ll populate this field with the Drivetrain object that is declared in \nRobotContainer, so that the OnBoardIO object can access the gyro that belongs to RobotContainer’s \nDrivetrain object. After declaring the Drivetrain object, initialize the OnBoardIO’s constructor method by \nadding a parameter of type Drivetrain, and setting the class’s Drivetrain object equal to the Drivetrain \nobject that is passed into the constructor. Remember, a constructor is a method in a class that exactly \nmatches the class’s name and has no return type. So in OnBoardIO, the constructor is the method \ndeclared on line 46 by the text “public OnBoardIO…” (it will be on line 47 after you declare the \nDrivetrain object. Here’s an example of the declaration and initializations: \n</p>",
                "image": "<img src=\"./images/lesson6_0.png\"/>",
                "more_images": "<img src=\"./images/lesson6_1.png\"/>"
            },
            "7": {
                "actionType": "Code",
                "content": "<p>After doing this and saving the file, you’ll have an error in RobotContainer.java because the line that \ninitializes the OnBoardIO object there doesn’t send a Drivetrain object. Navigate to line 31 in \nRobotContainer.java and update it to pass in the Drivetrain object that is created on the prior line. \n</p>",
                "image": "<img src=\"./images/lesson6_2.png\"/>"
            },
            "8": {
                "actionType": "Code",
                "content": "<p>You’re now done with the plumbing and ready to create the command that will actually do things. \nCreate a new command in the commands folder called ToggleLightsBasedOnGyro. After creating the \ncommand, add a class field of type OnBoardIO called m_io. You can declare this one using the keywords \n“private final”, as shown in the image below. After creating the field, initialize it in the constructor, also \nshown. The last thing you’ll need to do is call the “addRequirements” method and pass in the \nOnBoardIO that is sent to the constructor. This is the line that tells the command which subsystems it \nneeds to use. This is how the program manages which commands are running on a subsystem because \nany given subsystem can only run one command at once. You can run multiple commands at the same \ntime if they are on different subsystems, and the addRequirements method specifies which subsystems \neach command uses. Although this command that we’re making will read data from the drivetrain \nsubsystem, it only acts using the OnBoardIO subsystem, where it will turn lights on and off. So we do not \n“require” the drivetrain subsystem for this command in a programming sense, even though in an English \nsense it does need a drivetrain subsystem to read data from. Here’s a completed example: \n</p>",
                "image": "<img src=\"./images/lesson6_3.png\"/>"
            },
            "9": {
                "actionType": "Code",
                "content": "<p> \nNow it’s time to add the logic that reads the angle from the gyro and then turns the lights on \nand off accordingly. Doing this will be an example of how objects form a hierarchy of data. The \ncommand you’re working on is literally a class – you can see this on line 10 where you declare “public \nclass…”. This class has an OnBoardIO object, m_io. Every OnBoardIO object has a Drivetrain object \nbecause you gave it one on line 23 of OnBoardIO.java in a previous step. Every Drivetrain object has a \nRomiGyro object because of line 32 in Drivetrain.java (one of the lines you modified while setting up for \nthis project.) So from your ToggleLightsBasedOnGyro class, you can chain through your data hierarchy to \nget to the gyro: ToggleLightsBasedOnGryo -> OnBoardIO -> Drivetrain -> RomiGyro. The RomiGyro class \nhas a method called “getAngleZ()”, which returns a double value that represents an angle in degrees \n(you can see this if you open RomiGyro.java in the “sensors” folder, and look on line 108.) As you \nlearned in the materials for this lesson, you can use dots (periods) to chain through your objects. So to \ncall the getAngleZ() method, you can use your class variable m_io, and do \n“m_io.m_drivetrain.m_gyro.getAngleZ()”. \n</p>"
            },
            "10": {
                "actionType": "Code",
                "content": "<p>While a command is running, its execute method is called continuously. We want our lights to \nupdate continuously, so this is where we’ll put our code. Navigate to the execute() method in your \ncommand (approximately line 24), and as the first line of the method, declare a variable and set it equal \nto the output from the getAngleZ() method call described above. Here’s an example: \n</p>",
                "image": "<img src=\"./images/lesson6_4.png\"/>"
            },
            "11": {
                "actionType": "Read",
                "content": "<p>Now you have a variable that contains the current orientation of the robot, relative to the \nrobot’s orientation when the program started running, which will be whenever you press F5 and the \ncode loads onto the robot. Since execute() is called continuously while the command is running, this \nvariable will continue to be updated during execution. \n</p>"
            },
            "12": {
                "actionType": "Code",
                "content": "<p>Now that you have the angle, it’s time to turn lights on and off. To do this, you’ll want to use \ntwo methods belonging to the OnBoardIO class – setGreenLed(boolean) and setRedLed(boolean). Notice \nhow those methods are written here in plaintext, with the word “boolean” in the parentheses. This \ndemonstrates that in order to use them, you need to send a boolean variable. This makes sense – lights \nhave two states, on or off, so you can pass either true or false to the methods, to turn the light on or off. \nThere is one method for the green light and one method for the red light. In this project, we’ll set the \ngreen light to on if we’re on course, and the red light to on if we’re off course. In both cases we’ll set the \nother light to off, so there will only ever be one light on at a time. \n</p>"
            },
            "13": {
                "actionType": "Code",
                "content": "<p>You might want to turn the lights to one configuration, and you might want to turn them to a \ndifferent configuration, depending on the gyro angle. That means you’re going to need a conditional \nstatement. “Conditional” is just a fancy word for an if statement. If the gyro angle is zero, then the robot \nis facing straight ahead, and if it’s not, then the robot has turned a little bit. Of course, in practice, the \ngyro is sensitive, and the angle is not going to be exactly zero, so you’re going to need to check if it’s in \nsome range. If you make the range too big, say, 90 degrees, then you could veer far off course before \ndetecting it. If you make the range too small, say, one quarter degree, then you’re going to detect that \nyou’re off course even when you’re mostly straight. Finding the perfect range depends on a lot of things, \nbut for this project, a range of +/- five degrees works pretty well. \n</p>"
            },
            "14": {
                "actionType": "Code",
                "content": "<p>You could measure if the gyro angle is less than 5 degrees pretty easily, with a line like this: \n</p>",
                "image": "<img src=\"./images/lesson6_5.png\"/>"
            },
            "15": {
                "actionType": "Code",
                "content": "<p>However, the robot can turn in two different directions. If you turn the robot to the right, the gyro angle \nwill increase. If you turn to the left, it will decrease. This means that if you turn 90 degrees to the left \nrelative to the starting point, the gyro angle would return -90. This is indeed less than 5 degrees, so the \nif statement above would return true, even though you’d be very far from straight. Thankfully, there’s \nan easy solution to this, using something called “absolute value”. The absolute value of a number is \nsimply that number, but not negative. For example, the absolute value of 10 is 10. The absolute value of \n-10 is also 10. So the only difference is that if the number is negative, it becomes positive. If it’s already \npositive, there’s no change. Java has a built-in method to return the absolute value of any number: \nMath.abs(double). Math.abs(gyroAngle) will return whatever the gyro angle is, but positive. You can use \nthis function in your if statement to check if the absolute value of the gyro angle is less than five. Write \nthis if statement, and if it’s true, set the green LED to true and the red one to false, and vice versa if the \nif statement is false. Here’s an example: \n</p>",
                "image": "<img src=\"./images/lesson6_6.png\"/>"
            },
            "16": {
                "actionType": "Code",
                "content": "<p> \nWe could be done with this command at this point, but let’s make a couple quick upgrades \nbefore we finish. Since we’re still practicing our mastery of using methods, let’s split out lines 28 and 29, \nand 32 and 33 above, into their own methods. Beneath the execute() method, create two more \nmethods called “setLightsGreen()” and “setLightsRed()”. You can declare both of these with “private \nvoid”. Move the lines of code identified above into these methods, and inside your if statement in the \nexecute method, call your newly created methods. Lastly, you may want to add a SOP line that outputs \nthe gyro angle, so you can see it in real time in the terminal. This isn’t strictly necessary because you can \nalso see it on the robot simulation interface, but you can add it if you want. Here’s an example of the \ncommand with all these steps completed: \n</p>",
                "image": "<img src=\"./images/lesson6_7.png\"/>"
            },
            "17": {
                "actionType": "Code",
                "content": "<p> \nWith that done, your command is completed. The only thing left to do is set your command to \nbe the default command for the OnBoardIO subsystem. Since no other commands are issued to the \nOnBoardIO subsystem right now, setting your command as the default command means that it will run \nall the time, and therefore your execute method will run all the time. Navigate to the end of line 65 in \nRobotContainer.java and press enter. Then use the setDefaultCommand method you see on line 65, \nexcept call it for your OnBoardIO object instead of the drivetrain (remember, your OnBoardIO object, \nwhich is declared on line 31 of this file, is called m_onboardIO.) On line 65, the value passed to \nsetDefaultCommand is a method call, but for the the line you’re adding, you can just use the new \nkeyword to create an instance of your command. Remember, commands are classes, so you create \ninstances of them. To create an instance of your class, you need to send in the values its constructor \nrequires. In this case, it requires an OnBoardIO object, because the OnBoardIO object provides access to \neverything your command needs – the lights to toggle and the drivetrain object through which to find \nthe gyro angle. Conveniently, you only have one OnBoardIO object in your code, which makes sense \nbecause your robot physically only has a single on-board IO. The same m_onboardIO object that you’re \nassigning the default command to, can be sent in to your ToggleLightsBasedOnGyro constructor call, like \nso: \n</p>",
                "image": "<img src=\"./images/lesson6_8.png\"/>"
            },
            "18": {
                "actionType": "Code",
                "content": "<p> \nNow there’s just one tiny step to go. Navigate to the end of line 54 in RobotContainer.java, press \nenter, and then add four lines like so: \n</p>",
                "image": "<img src=\"./images/lesson6_9.png\"/>"
            },
            "19": {
                "actionType": "Robot",
                "content": "<p>All this does is initialize the values so that the lights turn on as soon as your code starts. With that, \nyou’re done – deploy your code! Make sure not to rotate your robot by hand before you enable it. \nWhen you enable teleoperated mode, you’ll see the green light illuminate. If you start rotating your \nrobot, either by driving it or by hand, you’ll see the lights change as the angle of the robot moves away \nfrom its initial orientation and change back if you move the robot back. \n</p>"
            },
            "20": {
                "actionType": "Read",
                "content": "<p> \nIn this lesson, you learned about OOP, and saw an example of how you can use classes and \nobjects in code to logically interact with different parts of your program through a class hierarchy. You \nalso saw an example of how you can integrate different subsystems on the Romi with each other to \ncreate some cool functionality. This was a longer lesson with a lot of important concepts, so don’t worry \nif you feel like you need to review any part of it. Although there are still a couple deep dives left to go \nbefore you’ll understand everything you see in the code, you’re making great progress. We’ll continue to \nbuild on these skills in future lessons. \n</p>"
            }
        },
        "totalParagraphs": 21
    },
    "Lesson 7 - OOP Deep Dive Part 2": {
        "Introduction": {
            "0": {
                "actionType": "Read",
                "content": "<p> \nIn lesson 6, you learned a lot about object-oriented programming, but there’s still more to learn, \nso we’re going to focus on that in this lesson. For the project, we’ll combine the new material you learn \nwith review, by revisiting the project from lesson 6 and doing it in an easier and better way using the \nnew knowledge you have. \n</p>"
            },
            "1": {
                "actionType": "Code",
                "content": "<p> \nYou previously read this page through section 2.9: \n<a href='https://www3.ntu.edu.sg/home/ehchua/programming/java/J3a_OOPBasics.html#zz-2.10'>https://www3.ntu.edu.sg/home/ehchua/programming/java/J3a_OOPBasics.html#zz-2.10</a> Today, \ncontinue doing so, starting at section 2.10 and reading through section 2.17. Stop when you get to \nsection 3. After you do, you’ll have a much better understanding of words you’ve been seeing pop up \neverywhere in the robot code, specifically “public”, “private”, and “final”. \n</p>"
            },
            "2": {
                "actionType": "Code",
                "content": "<p>Having finished the reading, you’re now ready to dive into the project, which is a redo of the \nproject from lesson 6 but applying the principles you learned from today’s reading. Create a new \nRomiReference project called GyroLights 2, and just like last time, change the “INPUT” words in \nRobotContainer line 31 to “OUTPUT”. \n</p>"
            },
            "3": {
                "actionType": "Code",
                "content": "<p>At this point in lesson 6, the next step was to change the RomiGyro variable declared on line 32 \nof Drivetrain.java from private to public. However, this time around we do NOT want to do that. As a \ngeneral rule, it’s better to have as many variables be private as possible. This is a safety measure so that \nexternal sources do not make unwanted changes to variables that could break your program. That might \nseem silly – you’re the author of your program, so as long as you don’t do that, what could go wrong? \nWell, in theory, you could get away with making everything public and never run into issues. However, \nin practice, most software projects include many people, not just one person, and no individual \nunderstands every line of the program. Team projects can easily be millions of lines. Somebody might \naccess a public variable and change it without realizing how it affects something else. Even if you’re not \nworking on a team project, you’re a human and humans make mistakes. It’s surprisingly easy to forget \nall the details of your own program, especially after some time passes. If you’re working on a tiny \nproject that takes only a couple of hours to finish then pragmatically, yes, it’s probably fine to make \neverything public. But projects have a way of growing past original expectations, and it doesn’t take \nmuch growth before making everything public becomes a problem. Accordingly, it’s a good idea to \nfollow best practices and just make everything private if you can, so this time around we will not make \nthe RomiGyro object public. \n</p>"
            },
            "4": {
                "actionType": "Code",
                "content": "<p>Following the same steps as last time, the next step was to create a public final Drivetrain object \nin OnBoardIO.java. We do need a Drivetrain object, but this time we don’t want it to be public or final. \nAs you learned in the reading, final means that the value will not be able to change once set, and we \ndon’t want that this time for reasons you’ll see shortly. So this time, declare a private Drivetrain object: \n</p>",
                "image": "<img src=\"./images/lesson7_0.png\"/>"
            },
            "5": {
                "actionType": "Code",
                "content": "<p>Now it’s time to practice something else you just learned about: overloading methods. To \noverload a method, you simply create two methods with the same name, but with different parameters. \nIn this case we’re going to overload the constructor by leaving the original constructor and creating a \nnew one that accepts a Drivetrain object. In lesson 6, we simply modified the original constructor. \nCreate a new constructor with the same two ChannelMode parameters, plus a Drivetrain parameter. \nYou’ll need the functionality of the original constructor in addition to the new code you write, so the \neasiest thing to do is to copy and paste the old constructor and then add to it. In your constructor, \ninitialize the OnBoardIO’s drivetrain variable. Here’s an example: \n</p>",
                "image": "<img src=\"./images/lesson7_1.png\"/>"
            },
            "6": {
                "actionType": "Code",
                "content": "<p>In lesson 6, after we modified the constructor, it caused syntax errors in other files because the \nexisting method calls no longer matched the parameters for the OnBoardIO (OBIO) constructor. By \ncreating an overloaded constructor, we do not get those syntax errors, because the old code exists. This \nis a great feature when adding to large projects that have a lot of references to existing methods \nalready. However, overloading is not always the right solution, and this project is actually a good \nexample of that. We create an overloaded constructor that initializes the Drivetrain object. We will be \nusing the Drivetrain object elsewhere in the method. But it is possible to create an OBIO object using the \noriginal constructor, which means it is possible to create an OBIO object that does not have an initialized \nDrivetrain object. If one were to do this, they would get an error if they later tried to use any of the code \nthat relies on the Drivetrain object. That may or may not be a problem depending on the program. This \nis a tradeoff to consider whenever choosing whether or not to overload a method. Overloading can \ncreate better backwards compatibility and more flexibility, but you have to make sure that all of the \noptions will work. In this case, if one used the old constructor and then tried to use the gyro lights \nfunctionality, it would most definitely not work, so if this were a production project, we would either not \ndo the overload, or come up with some other workaround. Since it’s not a production project, we’ll do \nthe overload and not worry about it too much, since the reason you’re doing this project is to learn and \nthinking about the tradeoffs accomplishes that goal. \n</p>",
                "image": "<img src=\"./images/lesson7_2.png\"/>"
            },
            "7": {
                "actionType": "Code",
                "content": "<p>If you look at the two constructors that now exist, you’ll notice that the lines of code in the \nimage above are repeated in both of them. A good rule is that whenever you see repeated lines of code, \nthey should be broken out into a separate method. This reduces the amount of clutter in your code, and \nif you ever need to change those lines, you’ll only need to change them in one place instead of tracking \ndown all the places they’re copied throughout your code. Let’s practice that here. Split the lines of code \npicture above out into their own method called “initializeDios” (you can declare this one using “private \nvoid”. Then call your new method in both of your constructors. Here’s how the class looks so far: \n</p>",
                "image": "<img src=\"./images/lesson7_3.png\"/>"
            },
            "8": {
                "actionType": "Code",
                "content": "<p> \nAnother thing you learned about from today’s reading is getter and setter methods. Let’s get \nsome practice using them. You created a Drivetrain variable in this class, so create getter and setter \nmethods for it. They’ll look like the photo below. Note that the order in which you put methods in a \nprogram does not make a functional difference, although it can make a difference in terms of how easy \nyour code is for humans to read. Everyone seems to have their own style for how to order methods. The \nmain reason you need to understand this right now is because your line numbers may or may not match \nexactly with the sample images if you’re putting your methods in different places, and that’s OK. \n</p>",
                "image": "<img src=\"./images/lesson7_4.png\"/>"
            },
            "9": {
                "actionType": "Code",
                "content": "<p> \nYou’re now done with your OBIO class modifications. Last time when you were done with this \nclass, you had syntax errors in other files, which pointed out to you exactly what you needed to change \nnext. This time however, since we overloaded the constructor, we don’t have those errors. But we still \nneed to change the code that initializes the OBIO because if we don’t use our new constructor method, \nthe Drivetrain object won’t get initialized. Go to line 32 in RobotContainer.java and update your \ndeclaration of the OBIO object accordingly. \n</p>",
                "image": "<img src=\"./images/lesson7_5.png\"/>"
            },
            "10": {
                "actionType": "Code",
                "content": "<p> \nNow it’s time to create the ToggleLightsBasedOnGyro (TLBOG) command again. For this you can \nfollow all the same steps you did in lesson 6, except there will be some changes to the execute method. \nTo start, follow the steps from lesson 6 exactly. You’ll notice that you get an error on the line where you \ntry to get the gyro angle. If you hover over the error, VSCode will explain to you that “m_drivetrain” is \nnot visible, which is because it was declared as private instead of public, and therefore cannot be \naccessed from this class: \n</p>",
                "image": "<img src=\"./images/lesson7_6.png\"/>"
            },
            "11": {
                "actionType": "Code",
                "content": "<p> \nThankfully, we prepared for this by creating a getter method for the drivetrain object. Replace \nthe “m_drivetrain” text with getDrivetrain(): \n</p>",
                "image": "<img src=\"./images/lesson7_7.png\"/>"
            },
            "12": {
                "actionType": "Code",
                "content": "<p>Now we don’t get an error on m_drivetrain, but we still have an error, and if you mouse over it you’ll \nsee that it’s the same error, because m_gyro is also not visible. Luckily for us, the sample project already \ncreated a get method for us. The get method isn’t actually for the gyro, but it’s for the gyro’s Z angle, \nwhich is exactly what we want. You can find this method by starting to type “get” after the period after \n“getDrivetrain()”. VSCode automatically checks which methods are available to you and starts listing \nthem out, which can be really handy for quickly finding the method you want to use. This feature is \ncalled intellisense. Select the “getGyroAngleZ()” method to complete the line. \n</p>",
                "image": "<img src=\"./images/lesson7_8.png\"/>",
                "more_images": "<img src=\"./images/lesson7_9.png\"/>"
            },
            "13": {
                "actionType": "Code",
                "content": "<p> \nThere’s only one more change to make to TLBOG relative to lesson 6. On line 27, you use the \nnumber 5 as part of your if statement. This is called a magic number. A magic number is a number that \nhas some real-world logical meaning for your code. In this case it’s the number of degrees off of \nperfectly straight that you’re allowing to count as straight. Magic numbers are a necessary evil because \nyou have to use them, but they can be problematic because when reading through code, unless one \nalready understands the significance of the number, the line of code may not make much sense to them. \nA good measure to reduce the pain of magical numbers is to group them together in a class that is \ndesigned purely to hold them. As it turns out, the RomiReference project already has a class designed \nexactly for this, called Constants.java. Larger projects might want a more specific name than that and \npotentially more than one class to serve this purpose – for example, AutonomousCalibrations.java, \nTeleopCalibrations.java, ButtonMappings.java (think back to all the numbers you have to mark down for \nyour axes and buttons), and so forth. But for now we’ll just use Constants.java. \n</p>"
            },
            "14": {
                "actionType": "Code",
                "content": "<p> \nGrouping magic numbers in a class has a couple of advantages. First, if you need to tune your \nrobot, the tuning levers are conveniently located in a single spot. Right now we only have one value to \ntune, which is this number of degrees. But we could add others. For example, the scaling coefficients \nthat you use for cut power mode would be well-suited to go in the Constants file as well. After you have \na few values like this throughout your program, grouping them all in one place gives you easy access to \ntune your robot without opening a ton of different files and searching through your code for where you \ndefined them. Additionally, sticking the values in a class lets you replace the number with a textual \ndescription of what the number does. This is best illustrated with an example. Here is a replacement for \nline 27: \n</p>",
                "image": "<img src=\"./images/lesson7_10.png\"/>"
            },
            "15": {
                "actionType": "Code",
                "content": "<p>If you read through this code as a human, you might not know what the degree threshold is, but you \nalso might not really care; you can read it and understand that the line of code is checking whether or \nnot the gyro angle is greater than the threshold for whether or not the robot is oriented straight. Unless \nyou’re in the process of tuning the robot, you probably care much more about whether or not it counts \nas straight, than exactly what the cutoff for that condition is. And as it turns out, it’s easy to see what \nthe value is if you want to know it anyway, as you’ll see in a moment. But first, after you replace line 27 \nwith the code above, let’s fix the syntax error. \n</p>"
            },
            "16": {
                "actionType": "Code",
                "content": "<p> \nIf you click on the red-underlined “Constants”, you’ll get a lightbulb on the left, and clicking it \nallows you to import Constants.java. Do so. Now “Constants” turns green but the all-caps text gets a red \nunderline of its own. Click on that and click the lightbulb and it will give you the option to automatically \ncreate a constant with that name inside Constants.java (the first option), so click that. Now the \nunderline goes away because it created the constant for you. But, it has no way of knowing what value \nyou want for that constant. Mouse over “IS_ORIENTED_STRAIGHT_DEGREE_THRESHOLD” once more \nand you’ll get a popup showing you the type (double) and value (0.0) of the constant: \n</p>",
                "image": "<img src=\"./images/lesson7_11.png\"/>"
            },
            "17": {
                "actionType": "Code",
                "content": "<p> \n0.0 is not what we want, but conveniently it’s easy to access and change. If you’re still hovering \nover the text, simply click, and then press F12, and VSCode will take you to Constants.java and to the \nline where this constant is declared. Now you can easily change the value to 5, save, and go back to \nTLBOG. If you mouse over the text one final time, you’ll see that not only is it easier to understand what \nthis line does because it’s written out in text, but you can easily see the value as well because it pops up \nwhen you mouse over it. \n</p>"
            },
            "18": {
                "actionType": "Code",
                "content": "<p> \nAll you need to do now to finish the project is the same steps you took to finish lesson 6 – set \nthe default command for OBIO and initialize the states of the LEDs, both in RobotContainer.java. After \nyou do these things, deploy your code to check your work! While it won’t do anything differently than \nlesson 6, your code is much cleaner this time around, and you learned a lot in the process. \n</p>"
            }
        },
        "totalParagraphs": 19
    },
    "Lesson 8 - Loops": {
        "Introduction": {
            "0": {
                "actionType": "",
                "content": "<p>Note: there is no included solution program for lesson 8. \n</p>"
            },
            "1": {
                "actionType": "",
                "content": "<p> \nIn this lesson we’re going to do a little bit more non-Romi practice in order to familiarize you \nwith some concepts that are critically important, but that you won’t see too much of in the Romi code. \nSpecifically, we’re going to talk about loops. A loop is a chunk of code that is designed to run multiple \ntimes. You may have already realized that this is happening in your Romi code, because the program \nruns indefinitely until you turn the robot off. The loops in the Romi code are behind the scenes a little \nbit, so not as visible to you. We will talk about where they exist and how they result in your code \nrunning indefinitely. We’ll also do some desktop practice without the Romi. The next two lessons will be \nreview and practice, with heavy focus on Romi projects as opposed to new code concepts. \n</p>"
            }
        },
        "Loops": {
            "2": {
                "actionType": "Code",
                "content": "<p>Start by watching this video, and follow along in a scratch project in VSCode: <a href='https://www.youtube.com/watch?v=6djggrlkHY8'>https://www.youtube.com/watch?v=6djggrlkHY8</a></p>"
            },
            "3": {
                "actionType": "Code",
                "content": "<p>Once you’re done with that, open a fresh Romi project. Open Robot.java. This file contains a \nnumber of methods that essentially are run in loops. Look at line 85, which is a method declaration for \nteleopPeriodic(). This function is called repeatedly while teleop is enabled. Right now there’s nothing in \nhere, but if you were to, for example, put a SOP in there and enable teleop, you would see it start \noutputting to the terminal. You can see the same thing for disabled, autonomous, and test modes on \nlines 53, 70, and 95, respectively. There’s also a method called robotPeriodic declared on line 40. This \none is similar but it runs all the time regardless of which mode the robot is in. Unlike the other methods, \nyou’ll notice this one does have a line of code in it – line 45, CommandScheduler.getInstance().run();. \nYou’ve created and used some commands in prior lessons, and this line is basically what makes them all \nwork, since robotPeriodic is running in a loop behind the scenes. When line 45 runs, an object called the \nCommandScheduler basically looks at all the commands that need to do things and makes them do \nthose things. You’ll learn more about commands as we keep working with Romi code, but this is where \nthe magic happens. Although you don’t see the words “for” or “while” in these examples, the concepts \nare the same. \n</p>"
            },
            "4": {
                "actionType": "Code",
                "content": "<p>Now let’s do some practice writing your own loops. Here are some exercises to complete in a \ndesktop VSCode project. They’ll give you practice using loops as well as reinforce your previously \ndeveloped skills. A quick note – why are we doing desktop projects for loops instead of Romi code? Well, \nthe simple answer is that if you mis-use loops in your robot code, you can create some dangerous \nsituations. You just saw that the command scheduler needs to run constantly in robotPeriodic. If you \nhave a loop in your robot code that doesn’t terminate quickly, not only can the commandScheduler not \nrun, but neither can any code that is not in your loop. That might include critical safety features like \ntelling your motors to turn off. If your motors are running full power and the code turning them off can’t \nrun, your robot will not be able to stop. There are situations where loops are good in robot code, but \nthey’re a bit fewer, further between, and often have to do with more advanced concepts. This, \ncombined with the fact that your code is already set up to effectively be self-looping because of your \ncommands running all the time and each mode of the robot having a period method where you can add \ncode that you want to run over and over, means you don’t need as many loops in your robot code. For \ndesktop applications, on the other hand, if you want your code to run over and over you’ll have to \ncreate that functionality yourself, meaning you’ll need a lot of loops. With that being said, here are the \nexercises. In lesson 4 you learned how to use the Scanner to generate user input. You’ll need to use the \nScanner again here. To complete these exercises, make one program, and one method for each exercise. \nIn your main method, call each exercise’s method, so your single completed program does all of the \nexercises. \n</p>"
            },
            "5": {
                "actionType": "Code",
                "content": "<p>1. Write a for loop that SOP’s every integer from 0 to 9. \n2. Write a while loop that outputs every integer from -10 to positive 20. \n3. Take an integer input from the user and compute the \"sum of squares\" from 1 to that \nnumber. For example, if the user entered 10, the answer would be 1^2 + 2^2 + ... + 10^2. \nOutput the answer. To check your work - if you enter 10, the answer should be 385. If you \nenter 11, it should be 506. You’ll need to declare a variable outside of your loop to keep \ntrack of the sum so far. \n</p>"
            },
            "6": {
                "actionType": "Code",
                "content": "<p>4. Take an integer input and compute the \"square of sum\" from 1 to that number. So if they \nentered 10, it would be (1 + 2 + ... + 10)^2. Output the answer. To check: 10 comes out to \n3025, and 11 comes out to 4356. \n</p>"
            },
            "7": {
                "actionType": "Code",
                "content": "<p>5. Now calculate the \"sum-square difference\" - that is, the difference between the square of \nsum and the sum of squares. So basically, the result of problem 2 minus the result of \nproblem 1. If you enter 100, the answer should be 25164150. \n</p>"
            },
            "8": {
                "actionType": "Code",
                "content": "<div><p>6. Output a multiplication table for 1-10. Note that in order to do this you will need to do something a bit new - a \"nested\" loop. You'll have one for loop that goes from 1 to 10, and \nthen you'll have another for loop that also goes from 1 to 10 inside the first for loop. Your \nnested for loop will complete fully for every cycle of the outer loop. Remember that you can \nuse System.out.print instead of .println to output something without a new line, and you \ncan do System.out.println(\"\"); to output a new line and nothing else. So your result should \nlook something like the following (the exact spacing of the numbers isn’t too important.)</p><p>1 2 3 4 5 6 7 8 9 10</p><p>2 4 6 8 10 12 14 16 18 20</p><p>3 6 9 12 15 18 21 24 27 30</p><p>.....</p><p>10 20 30 40 50 60 70 80 90 100</p></div>"
            }
        },
        "totalParagraphs": 9
    },
    "Lesson 9 - Gyro Project": {
        "Introduction": {
            "0": {
                "actionType": "Read",
                "content": "<p> \nThis lesson gives you a chance to practice coding, while introducing a new concept called \n“modulo”, which takes a bit of thinking to understand in a mathematical concept, but as you will see is \neasy to use in terms of writing code. You learned about the gyroscope in an earlier lesson when you \nused it to turn lights on and off based on the rotation of the robot. In this project, we’re going to use it \nto ensure that the robot drives in a straight line and can maintain a given orientation.  \n</p>"
            },
            "1": {
                "actionType": "Read",
                "content": "<p>Note: This lesson is a bit heavy on math. The concepts aren’t super advanced, but there is a fair \namount of arithmetic that goes into it. If it starts getting confusing reading a lot of numbers, take your \ntime, slow down, read it again slowly, and then proceed. \n</p>"
            },
            "2": {
                "actionType": "Read",
                "content": "<p> \nThe gist of this project is that we will keep track of a target heading, and then constantly \nmeasure the current heading relative to the target heading and “add turning” relative to the difference \nbetween the target and the actual. If the difference is large, we’ll add a lot of turning. If the difference is \nsmall, we’ll add a small amount of turning.</p>"
            }
        },
        "Heading": {
            "3": {
                "actionType": "Code",
                "content": "<p>Let’s talk about what the word “heading” means in context. We will declare a variable \nrepresenting the target heading of the Romi in the Drivetrain class. Here’s an example. You can go ahead \nand create a new RomiReference project called DriveStraight and copy this into your code in \nDrivetrain.java: \n</p>",
                "image": "<img src=\"./images/lesson9_0.png\"/>"
            },
            "4": {
                "actionType": "Code",
                "content": "<p>This heading will be relative to whatever the heading of the robot was the last time the \ngyroscope was reset. You can reset the gyro anytime you want in code, but if you don’t do that, by \ndefault the last time it is reset would be when the gyro first initializes when you turn the robot on. \nAssuming you’re not rotating or moving the robot during its boot sequence, you don’t need to worry \nabout this too much – you can assume that the “default” orientation is whatever direction the robot is \nfacing when it turns on, and therefore that orientation would be a heading of zero. As you saw last time \nwe used the gyro, you can use the getAngleZ() method to return the current heading in degrees. Before \nwe continue, let’s make sure to initialize our targetHeading so that it does, in fact, use the heading of \nthe robot when it boots. You can add this line of code to line 45 of Drivetrain.java. When the Drivetrain \nobject is initialized, the current heading will be stored as the target heading. \n</p>",
                "image": "<img src=\"./images/lesson9_1.png\"/>"
            },
            "5": {
                "actionType": "Read",
                "content": "<p>The getAngleZ method returns a double, and even though headings are relative to a 360 degree \ncircle, getAngleZ() does NOT necessarily return a value between 0 and 360. If you turn the robot left \n(counterclockwise) 90 degrees, you’d get a value of -90. If you spin the robot right (clockwise) two full \nrevolutions from zero, you’d get a value of 720. If you spin the robot one and three-quarters revolutions \nleft from zero, you’d get a heading of -630. This is important because if you’re starting at zero, you might \nassume a negative number means you rotated the robot left, but -630 is the same orientation as \npositive 90. Rotating the robot left one and three-quarters revolutions puts it at the same orientation as \nrotating it one quarter revolution right. \n</p>"
            }
        },
        "Modulo": {
            "6": {
                "actionType": "Read",
                "content": "<p>When we made the lights turn on and off, we didn’t worry about this. You could load your \nprogram and spin the robot a full revolution and check this for yourself – even if it’s at the proper \norientation, the red light will stay on because we did not account for this. For that project, that was fine, \nbut if you want to actually use the gyro to do useful things with the robot this is a problem. If you’re \nactually driving the robot around you don’t want to worry about how many times you’ve spun in a circle \nin order for your code to work. So we need a way to account for this, and luckily for us there’s an easy \nsolution using what’s called “modulo”. \n</p>"
            },
            "7": {
                "actionType": "Read",
                "content": "<p> \nYou may have never heard the term modulo before but you’re already familiar with it if you’ve \never used a clock or a calendar. What time is it right now? Chances are, it’s some hour between 0 and 12 \nor 0 and 24, depending on what kind of clock you like to use. And what day of the month is it? Chances \nare it’s something between 1 and 31. But obviously you’ve lived a lot more than 24 hours and a lot more \nthan 31 days. But after each cycle, these numbers reset and start counting again. This is because we’re \ninterested in how much time has passed since the start of the most recent cycle. It’s the same thing with \nthe gyro – we’re interested in how much change there has been since the last time the heading passed \nthe origin point, regardless of whether it read 0, 360, -720, or whatever else when it passed the origin. \n</p>"
            },
            "8": {
                "actionType": "Read",
                "content": "<p> How do you <i>do</i> modulo math? Well, you’ve probably done this before as well, if you’ve ever  done division and calculated the remainder. Let’s go back to our calendar example. If you asked  someone what hour it is when it was, say, 11 AM on January 1st 2021, they’d probably say it’s 11. They <i>could</i> say it’s 17,703,971, which is approximately the number of hours that have passed since the  beginning of the day on January 1st at the start of the AD calendar, but they wouldn’t do that. What they <i>would</i> do, without realizing it, is take 17,703,871, divide it by 24, and tell you the remainder of that  operation, which happens to be 11. This is called <i>modulo division</i> – instead of giving you answer to  17703871/24, which is 737665.45833, they’d round that to an integer and give the remainder.  </p>"
            },
            "9": {
                "actionType": "Code",
                "content": "<p> \nYou’re familiar with the basic mathematical operators: +, -, /, and *. But there’s an additional \noperator you might not be familiar with: the modulo operator, “%”. In Java, the percent sign will do \nremainder division, or modulo, on the number on its left. So for example: \nSystem.out.println(10 % 3); \nOutputs “1”, because if you were do integer division of 10 by 3, you would get 3 with a remainder of 1. \nBy the way, “10 % 3” would be read as “ten modulo three”, or “ten mod three” for short. Modulo works \nfor negative numbers as well; just like 10 mod 3 is 1, -10 mod 3 is negative -1 because 3 goes into 10 \nnegative three times, with a remainder of -1. Modulo division has a lot of everyday uses. Obviously time \nand date stuff is a big example, but it also becomes relevant for things like splitting up food and figuring \nout how much will be left over. Try to think of a couple examples in real life. As a quick project, go back \nto your lesson four project – the methods deep dive project where you created several calculator-type \nmethods like add, subtract, etc., and create a modulo method that takes two integers as parameters, \nmods one by the other, and returns the result to your main method where you output it. So your main \nmethod would include a line like this: \n</p>",
                "image": "<img src=\"./images/lesson9_2.png\"/>"
            },
            "10": {
                "actionType": "Read",
                "content": "<p>  Focusing back on the robot, we’re working with a degree system with 360 logical degrees, but a  range which we’d like to keep in between -180 and 180. We can use modulo to take any heading, and  make it between 0 and 360, by modding by 360. When modding by 360, any value between -360 and  360 will not change. (This range is NOT inclusive: -360 and 360 would each return 0, but 359.999 would  be unchanged.) Any value with <i>absolute value</i> (which you learned about in a prior lesson) of 360 or  higher will be brought down to be within the range of -360 to 360, without changing its logical meaning.  450 will become 90, 560 will become 200, etc. Here’s an example of a line of code that does this,  assuming the heading is stored in a double variable called “heading”. You don’t need to write this  anywhere just yet, this is simply an illustration of the concept.  </p>",
                "image": "<img src=\"./images/lesson9_3.png\"/>"
            },
            "11": {
                "actionType": "Read",
                "content": "<p>This takes us halfway there, but we want to ensure the final output is between -180 and 180, \ninstead of between -360 and 360. If we were to use a range of between -360 and 360, it would actually \nstill work orient the robot properly, it just might turn the long way around – e.g. instead of turning ten \ndegrees left, it might turn 350 degrees right. Considering you would only need to veer one degree off \ncourse to then trigger a 359 degree correction, this would be functionally undriveable even though it’s \n“mathematically correct”. So we definitely need to reduce our range further. \n</p>"
            },
            "12": {
                "actionType": "Read",
                "content": "<p> \nLogically we can do this range reduction using a couple if statements. We know that any value \nbetween -360 and -180 corresponds to a value between 0 and 180. For example, -350 corresponds to \n10, -190 corresponds to 170, etc. All we have to do is add 360. The same goes for the range of values \nbetween 180 and 360: they correspond to values from -180 to 0. For these values we need to subtract \n360 instead of adding it. We can use simple if statements to accomplish this – if the value is less than -\n180, add 360 to it to make it between 0 and 180. If it’s greater than 180, subtract 360 to make it \nbetween -180 and 0. Here’s an example of that, and again this is not something you need to write \nsomewhere yet, but an illustration of the concept: \n</p>",
                "image": "<img src=\"./images/lesson9_4.png\"/>"
            },
            "13": {
                "actionType": "Read",
                "content": "<p>  These chunks of code demonstrate how to get a heading value to within a desired range using  modulo. But how do we use any of this in our robot code? The trick is going to be using our  targetHeading variable declared earlier and <i>comparing it to the current heading</i>. The difference between  two headings is also a heading. For example, if you have a target heading of 60 degrees and a current  heading of 30 degrees, then the difference between those headings is 30 degrees, which is itself a  heading. We will add turning from how much output we send to the wheels based on the magnitude of  this heading. If the difference between the headings is small, say, just one degree, we’ll only add a very  small amount of turning power. If it’s large, such as 30 degrees, we’ll add a large amount of turning.  </p>"
            }
        },
        "Modifying Turning Power": {
            "14": {
                "actionType": "Code",
                "content": "<p>You’ve modified the turning power of the robot before, way back in lesson 2 when you opened \nthe Drivetrain.arcadeDrive method and modified the zaxisRotate variable, and then again in lesson 5 \nwhen you added cut power mode. We’re going to do the same thing here but instead of scaling it by a \nstatic amount, we’ll scale it by a dynamic amount based on the difference between the target and \ncurrent headings as described above. To do this you’ll make a method that handles all the logic \ndescribed in the prior section, but first, here’s an example of how you can set up your arcadeDrive \nmethod to apply the result. Note how you call a method which will have a dynamic result, and then \nsimply add the value to zaxisRotate. In this case you actually subtract it because of how the math works \nout, but of course subtraction is simply “addition of a negative number”, so that’s why you can think of \nthis as “adding turning”. You can go ahead and write this code, and then we’ll create the \ngetGyroAdjustment method. \n</p>",
                "image": "<img src=\"./images/lesson9_5.png\"/>"
            }
        },
        "Getting the Gyro Adjustment": {
            "15": {
                "actionType": "Code",
                "content": "<div><p>With arcadeDrive setup, it’s time to apply everything you learned about headings and modulo to  calculate the adjustment. It was a lot of reading, but as you saw, a fairly short amount of code, so this  method isn’t too hard. Follow these steps to complete it. An example is below, but see how much you  can complete yourself before looking at the example (see picture at 74% of lesson as well)</p><ol><li>Declare the “getGyroAdjustment” method, which should be private and return a double.</li><li>Declare a double variable “headingDifference” and set it equal the gyro’s current z angle minus the target heading. </li><li>Mod the heading difference by 360.</li><li>Apply the two if statements shown above to make sure the range of the heading difference is between -180 and 180.</li></ol></div>"
            }
        },
        "between -180 and 180.": {
            "16": {
                "actionType": "Code",
                "content": "<p>At this point, the headingDifference variable is ready to go. However, if you think about what you added to arcadeDrive, you’re subtracting gyroAdjust from zaxisRotate. The final value of zaxisRotate needs to be between -1 and 1, and if it’s outside of that range it will simply be truncated to that range. E.g. if you provide a value of 15, that will get truncated down to 1, and a value of -200 will get truncated to -1. Either of these would result in sending 100% turning power to zaxisRotate, which is usually not what you want. If the headingDifference is 1, that means the robot is off from its target by one degree – you definitely do not want to compensate for a one degree difference by  turning at full throttle. So you’ll need to apply a scaling factor to the headingDifference in order to  get a reasonable final value for your gyro adjustment. Declare a constant in the constants class for  this (use the lightbulb to import Constants in Drivetrain.) You can play around with what value you  want, but for starters .01 works alright. If you set this value too low, then your code will not do  much, because you’ve scaled the effect down to almost 0. If you set it too high, your robot will start  spinning back and forth uncontrollably because it will turn with too much power, overshoot the  target, and then turn back the other with full power and overshoot it again, etc. So it’s generally  wise to start with a low number and bump it up slowly if you need more power, than to start with a  high number. Here’s an example of the declaration in Constants.java and the line in Drivetrain.java  applying the scale. Note how a new variable “gyroAdjust” is declared; this isn’t strictly necessary  although after you apply the scale, the variable is longer logically a “headingDifference” so declaring  a new variable to represent what the value logically is can be a good idea.  </p>",
                "image": "<img src=\"./images/lesson9_6.png\"/>",
                "more_images": "<img src=\"./images/lesson9_7.png\"/>"
            }
        },
        "": {
            "17": {
                "actionType": "Code",
                "content": "<p>After you’ve done this, the last thing you need to do is use the return keyword to return your \nnewly created gyroAdjust variable. Here’s an example of the completed method: \n</p>",
                "image": "<img src=\"./images/lesson9_8.png\"/>"
            }
        },
        "Testing & Improving": {
            "18": {
                "actionType": "Robot",
                "content": "<p>At this point, you can deploy your code, and if you test it, you will notice that your robot will do \nits best to return to its starting orientation. There are two good ways to test this. The first is to put the \nRomi on some small object that you can lift up and rotate around, for example a tray or a large plate. If \nyou spin the tray around, you’ll see the Romi start spinning the opposite direction, trying to find its \noriginal orientation again. It will get pretty close. Our code isn’t perfect – for example, it might get close, \nbut then the power it sends to try and turn is not enough to break surface friction of the wheels on the \ntray. There are more advanced things you can do to account for this problem but for today’s lesson, this \nis good enough. Another way you can test is by turning the robot using the joystick. If you do this you’ll \nagain see it try to snap back to the original heading. Since the way we’re re-orienting the robot is by \nmodifying the zaxisRotate value, you might even notice that you can stall the robot in a different \norientation if you apply partial power to the rotation joystick, because you’ll be applying a turning \npower that cancels out the turning correction. \n</p>"
            },
            "19": {
                "actionType": "Read",
                "content": "<p> \nHaving your robot continuously self-adjust back to the original orientation is pretty cool! But, if \nyou did the test where you turned the robot using the joystick and it snapped back, you might have \nalready noticed a problem with our code. Sure, you can drive straight, but what if you want to turn? It \nmay be possible using the stalling trick described in the last paragraph, but realistically, you can’t turn \nyour robot with this code. The problem is that the robot’s target heading is never updated when we \nwant to give it a new target heading. Let’s finish out this lesson by making a small improvement to the \ncode to update the target heading whenever we turn. Then the robot will have a new target heading \ninstead of trying to correct back to the old one. \n</p>"
            }
        },
        "Detecting Turning & Deadband": {
            "20": {
                "actionType": "Code",
                "content": "<p>A first pass at detecting whether or not the driver is turning the robot is pretty simple. In the \narcadeDrive method, you have the variable zaxisRotate that you’re modifying to change the turning \nvalue, but its original value comes from the user’s control over the rotation joystick. In theory, if this \nvalue is nonzero, the driver is trying to turn. In practice, since it’s a physical joystick, at rest it may not \nmeasure zero – it will probably be close to zero, but if the driver releases it, it won’t return exactly to \nzero. There is a concept in robot control called “deadbanding” which basically means creating a \ndeadband, or a zone where inputs get reduced to zero. For example, you could decide that any value \nbetween -.1 to .1 should be counted as zero. We’ll talk about this more in future lessons when we \ndiscuss other ways to improve user input. For now just keep in mind that you’ll need to check if the \nmagnitude of zaxisRotate is bigger than some value, and if it is, you can assume that the user is trying to \nturn. When you’re checking the magnitude of a value, that’s usually a good use case for using absolute \nvalue, which you learned about in a prior lesson. Take your best shot at writing an if statement that \nchecks whether or not the user is trying to turn. As for a value to compare the zaxisRotate to, it will \ndepend on your physical controller. With a newer, stiffer controller that returns to center well, .1 might \nbe a good number. If you have an older controller and the joystick has more play, you might need a \nbigger number, even as large as .25 or .3. You can use the Joysticks window of in the Robot Simulation \ninterface to check this; find the joystick you’re using for control, flick your joystick a few times, and see \nwhat number it comes to rest on. Pick a number slightly higher than the largest value you see after a few \nflicks. With an Xbox controller this is axis 4. Once you have a value, declare it in your Constants file and \nuse it to finish your if statement. \n</p>",
                "image": "<img src=\"./images/lesson9_9.png\"/>"
            },
            "21": {
                "actionType": "Code",
                "content": "<p> \nOnce you’ve created your if statement, the last thing you need to do is adjust the target heading \nif the statement returns true. This is simple: just set the target heading to the current heading. You don’t \nknow what the target heading will be when the robot finishes turning, but since your if statement will \nrun constantly while the robot is turning, it will keep updating the target on the fly every time. Here’s a \nsample completed if statement: \n</p>",
                "image": "<img src=\"./images/lesson9_10.png\"/>"
            },
            "22": {
                "actionType": "Robot",
                "content": "<p> \nCongratulations, you’re now done! Test your code. You’ll see that after turning, the robot does \nnot snap back to its original orientation, but if you do the same test where you set it on a tray and rotate \nthe tray, it will still rotate. You might notice one issue: after turning, the robot will snap back a little bit \nin the opposite direction, and then snap back a second time in the same direction you were originally \nturning. This happens because the target heading is being set while the joystick is being held, but it takes \na small amount of time to stop turning after the joystick is released due to the robot’s current \nmomentum. However, the target heading will be locked in as soon as the joystick is released, meaning \nthat the robot will overshoot its target, and then start correcting for it. There are ways to deal with this \nproblem and we’ll look at one of them in lesson 11. For now, you’ve done enough to complete this \nlesson.  \n</p>"
            }
        },
        "totalParagraphs": 23
    },
    "Lesson 10 - Autonomous Commands": {
        "Introduction": {
            "0": {
                "actionType": "Read",
                "content": "<p><i>Note: there is no included solution program for lesson 10.</i></p>"
            },
            "1": {
                "actionType": "Read",
                "content": "<p>  In this lesson you’ll work with the Romi’s autonomous mode and learn more about commands  and how they can be combined together using <i>command groups</i>, which are lists of commands that run  sequentially one after another, or potentially at the same time if they act on different subsystems. For  today we’ll focus only on commands running sequentially. Learning about commands and command  groups will connect a lot of the concepts that you’ve been working with and when you finish this lesson,  you’ll have a much greater understanding of how all these classes, files, and methods work together to  make your robot code run. For the project you’ll make your own autonomous routines.  </p>"
            }
        },
        "Commands": {
            "2": {
                "actionType": "Read",
                "content": "<p>You’ve used commands already in the course, but we haven’t covered the details of how they’re \nstructured. Let’s talk about that a little bit more. The RomiReference project is written using the \n“command-based” paradigm, which allows a lot of things to happen without us doing them manually, \nfor example your arcadeDrive method running all the time. There are other ways to write robot \nprograms that aren’t command-based, but this course focuses on command-based because it has a lot \nof advantages which will become clear to you during this lesson. We will not discuss other paradigms in \nthis course, but you’re free to explore them on your own. \n</p>"
            },
            "3": {
                "actionType": "Code",
                "content": "<div><p>In the command-based paradigm, there is one class that is responsible for doing all the heavy  lifting behind the scenes, called the CommandScheduler. We discussed this very briefly in the loops  lesson and you can find this object on line 45 of Robot.java. It’s accessed every cycle of robotPeriodic,  which runs constantly while your robot is turned on. The CommandScheduler looks at all the commands  in your code, figures out which of them should be started, executed, and ended, and performs those  actions. In the process of doing this, the CommandScheduler is looking for specific things in a command,  for example the execute() method. It will call the execute method, which is how the code you’ve put in  the execute method of the commands you’ve written or modified gets run. We’ve also discussed how  only one command can run on any given subsystem (like Drivetrain) at once. The CommandScheduler is  what manages this, overriding old commands when new commands are issued. If you wanted to, you  could click on the green text “CommandScheduler” on line 45, press F12, and start investigating it  yourself. However, this is pretty advanced and I don’t necessarily recommend you do this – it’s just  interesting to know that you could. Most people programming Romis never need to do this and you can  just let the CommandScheduler run, working its magic behind the scenes. However, you will need to  understand the various parts of what makes up a command, so let’s take a look at one that you’ve  already worked with.</p><p>Create a new RomiReference project called “Autonomous” and open ArcadeDrive.java. Let’s dive  into the different portions of this file. All commands share a number of features, by nature of being a  class, and by nature of being a command.</p><ul><li>Lines 12-14: class fields. You’ve learned about these as part of learning about classes and doing  the projects. All classes in Java have this portion, although you could have a class without any  class fields. (This “area” of the code technically still exists, even if you don’t have any fields  there.)</li><li>Lines 24-32: class constructor, and where parameters are passed to the class. You’ve worked  with this as well. All Java classes have constructors, although like with the fields, they aren’t  always explicitly declared.</li><li>Lines 34-36: initialize method. On line 35 you’ll see “@Override”. We’ll talk about overrides  more in lesson 14. Whenever you see this tag, it means that the method exists because of what  kind of class it is. In this case, that means that all classes that are commands have initialize()  methods. Whenever you create a new command using the VSCode interface, it will have an  initialize method. If you read the comment on 34, it explains the initialize method: “Called when  the command is initially scheduled.” Scheduling a command is often the same as running it,  although not always, as it’s possible that the scheduled command will have to wait for the  subsystems it needs to become available to it. Don’t worry about that right now – the point of  the initialize method is that it runs when the command is scheduled, or in other words, when it’s  sent to the CommandScheduler to be run.</li><li>Lines 38-42: execute method. We’ve talked about this one a bit already. Since it has an override  tag, you know this is another method that exists because it’s a command. This method gets  called constantly while the command is running. In the case of ArcadeDrive, it’s how you drive  your robot.</li><li>Lines 44-46: end method. This method gets called when the command is either interrupted,  such as by another command overriding it using the same subsystem, or when the command  finishes (see the next bullet.)</li><li>Lines 48-52: isFinished method. This method runs every cycle as well, just like execute. If it ever  returns true, the command schedule will terminate the command and call the end method. In  the case of ArcadeDrive, we always want to be able to drive the robot, so this method is  hardcoded to always return false, so the command does not end. This is also the default code  that you’ll see any time you create a new command. However, many commands should end  after they do something. For example, say you had a command to drive forward ten inches in  autonomous mode. Such a command should end after the robot drives ten inches forward. So  instead of always returning false, isFinished would check how far the robot has traveled, and  return true or false accordingly.</li></ul></div>"
            },
            "4": {
                "actionType": "Code",
                "content": "<p>These four methods – initialize, execute, end, and isFinished – are the four main features of a \ncommand. Let’s look at another command that uses more of these features. In the commands \nfolder, open DriveDistance.java. As you might infer from the name, this command makes the robot \ndrive a specified distance, in inches. Let’s go through this command line-by-line and gain a complete \nunderstanding. \n</p>"
            },
            "5": {
                "actionType": "Search",
                "content": "<p>Line 10 declares the class, and the “extends CommandBase” text specifies that this class is a \ncommand. We’ll talk about this in a future lesson – for now you can just recognize it and understand \nthat it means it’s a command. Then there are three class fields declared – the Drivetrain system to \noperate upon, and the speed and distance with which to drive. \n</p>",
                "image": "<img src=\"./images/lesson10_0.png\"/>"
            },
            "6": {
                "actionType": "Search",
                "content": "<p> \nThis is the constructor for DriveDistance – remember, constructors have no return types, and \ntheir method names match their class names. Only constructor methods have these features. This \nconstructor initializes the class variables declared on lines 11-13, and calls the addRequirements method \nto specify that this command requires the drivetrain. Specifying requirements is how the \nCommandScheduler knows how to manage which commands run on which subsystems. \n</p>",
                "image": "<img src=\"./images/lesson10_1.png\"/>"
            },
            "7": {
                "actionType": "Search",
                "content": "<p> \nThese lines define the initialize method for DriveDistance. In this case, line 33 tells the robot to \nstop, by giving it zero power and zero turn. Line 34 resets the encoders to make sure that they’re \nmeasuring from zero when the command starts. If the robot had already been driven around (or rolled \nby hand) when the command starts, and the encoders weren’t reset, then the distance measurements \nwould be wrong. There are other ways to account for that, but by default, this command just resets all \nthe measurements to zero when the command is scheduled. \n</p>",
                "image": "<img src=\"./images/lesson10_2.png\"/>"
            },
            "8": {
                "actionType": "Search",
                "content": "<p> \nThese lines define what the command should do while executing. This command is called \n“DriveDistance”, and only drives in a straight line, so this method is pretty simple – drive the robot with \nthe speed specified when the command was initialized, and supply 0 power to turning to go in a straight \nline. As this is the execute method, it will be called continuously while the command is running. \n</p>",
                "image": "<img src=\"./images/lesson10_3.png\"/>"
            },
            "9": {
                "actionType": "Search",
                "content": "<p> \nThese lines define the end method, which as the comment on line 43 states, is called when the \ncommand either finishes or gets interrupted. Commands end when their isFinished method returns true, \nand the most common way to be interrupted is if another command that requires a subsystem the \ncommand requires is scheduled. For example, you could add code to your robot such that if you press a \nbutton on your controller, it immediately defaults back to operator control, which would interrupt \nDriveDistance because operator control would require the drivetrain. Either way, this method tells the \nrobot to stop when DriveDistance ends. You may want the robot to continue moving after DriveDistance \nends. For example, the default autonomous mode will have the robot spin 180 degrees after it drives \nten inches. This works because unlike the execute method, the end method is called only one time. So \nwhile the end method will stop the robot, it will be very brief and only last until the next line of code \nthat sets the robot’s speed/turning executes. (Of course, it is possible that the next line that sets the \nrobot’s speed continues to set its speed to zero.) Note that line 45 takes a boolean variable \n“interrupted”, so you can know whether your command finished on its own or something interrupted it. \nThis can be useful if you have logic that depends on knowing whether or not your command successfully \ncompleted or was overridden. \n</p>",
                "image": "<img src=\"./images/lesson10_4.png\"/>"
            },
            "10": {
                "actionType": "Search",
                "content": "<p> \nThese lines define the last method if of the DriveDistance class/command, the isFinished \nmethod. All the other isFinished methods we’ve looked at so far simply return false, however for driving \na set distance we want to stop after the distance has been driven, so this isFinished method needs to \nactually check something. In this case, line 53 calls a method called “getAverageDistanceInch”, which \nreturns a number of inches that the robot has traveled using the encoders, and compares it to the \ndistance the robot is supposed to travel. You can F12 into this method (and its sub-methods) if you want \nto see how it works, or you can take it for granted that it returns accurate values. Either way, if the \ndistance traveled is greater than or equal to m_distance, isFinished will return true, and when that \nhappens, the command’s end method will run and then the command will be over. Note that Math.abs \nis used here because the distance returned by getAverageDistanceInch will be negative if the robot is \ndriving in reverse. \n</p>",
                "image": "<img src=\"./images/lesson10_5.png\"/>"
            },
            "11": {
                "actionType": "Read",
                "content": "<p> \nWe’ve now looked through every line of code in this class, and hopefully you now have a decent \nunderstanding of an entire file of Java code! Obviously there are still a few things we haven’t gone in \ndepth into just yet, but you should now understand the various methods and why they exist. Commands \ncan have more than just these methods. For example, you could define additional methods in \nDriveDistance that are called by these standard methods while your command is running. But these \nmethods are the methods you’ll see in every command and that you need to understand. \n</p>"
            }
        },
        "Command Groups": {
            "12": {
                "actionType": "Code",
                "content": "<p>Now that you understand more about individual commands, it’s time to call about command \ngroups. Command groups are fairly simple – they are literally just groups of commands. The commands \ncan be run in sequence or in parallel. In order to run them in parallel they need to run on different \nsubsystems because only one command can be run on any given subsystem at once. For today we’ll \nfocus only on commands running sequentially. In a sequential command group, the logic flow is pretty \nstraightforward. As soon as one command finishes running – its isFinished returns true, and its end \nmethod gets called – the next command will start running. Your code already has a sequential command \ngroup defined by default so let’s take a look at it. Open AutonomousDistance.java in the commands \nfolder. \n</p>"
            },
            "13": {
                "actionType": "Search",
                "content": "<p> \nLine 10 of AutonomousDistance declares the class and you’ll see that it says “extends \nSequentialCommandGroup”. Just like when we investigated DriveDistance, we’ll ignore what the word \n“extends” means just for now, but just like in DriveDistance “extends CommandBase” meant that \nDriveDistance was a command, “extends SequentialCommandGroup” in AutonomousDistance means \nthat AutonomousDistance is a sequential command group. That is a lot of words, so just to repeat: the \ntext “extends SequentialCommandGroup” means that the class is a sequential command group. \n</p>"
            },
            "14": {
                "actionType": "Search",
                "content": "<p>Sequential command group classes tend to be fairly short and simple because basically all they do is list a bunch of commands that are meant to run in a sequence. AutonomousDistance is a great example of this. Other than line 10, this class only has a couple lines of code. Line 17 declares the constructor, which requires a drivetrain to act upon. Lines 18-22 are actually a single logical line of code, but it’s split over several lines of code for clarity reasons. Notice how there is a semi-colon at the end of line 22, but not at the end of the other lines. We touched on semi-colons earlier, and you’ve been using them in your code. You may or may not have noticed this, but you can put as much whitespace as you want in your code without it having any effect, even on an individual line of code. There is only one semicolon for lines 18-22 because it’s a single line, but with line breaks splitting out each sub-line after each comma to make it more readable.</p>"
            },
            "15": {
                "actionType": "Read",
                "content": "<p> \nWe’ll talk about the details of how it works in a moment, but chances are, if you look at lines 18-\n22 and read the text there, you can take a good guess at what it’s doing, especially if you’ve already run \nyour Romi’s autonomous code. It makes the robot drive a distance, specifically 10 inches. Then it makes \nthe robot turn 180 degrees. Then it drives ten more inches. Finally, it turns 180 degrees again. Each of \nthese actions corresponds to one of the sub-lines between lines 19 and 22 of the file. Each of these sub-\nlines is a command, and as soon as one of them finishes, the next one automatically starts. That’s the \nmagic of sequential command groups. You don’t need to worry about managing when your commands \nstop and start – the CommandScheduler does that for you. \n</p>"
            },
            "16": {
                "actionType": "Search",
                "content": "<p> \nLet’s dive into the details. As discussed, line 18 is one method call. Click on “addCommands” and \npress F12 to see the method declaration. This takes you to line 31 of the definition for the class \nSequentialCommandGroup: \n</p>",
                "image": "<img src=\"./images/lesson10_6.png\"/>"
            },
            "17": {
                "actionType": "Search",
                "content": "<p>You can see here that addCommands takes a Command parameter, but instead of just saying \n“Command commands” it says “Command… commands”. In Java, the three periods means that the \nmethod can take a variable number of objects of the specified type. It could be one, it could be zero, it \ncould be ten or a hundred. We’re not going to cover how the receiving method deals with receiving \nthese objects, but just understand what the three periods mean. You can pass any number of Command \nobjects to the addCommands method. Now go back to AutonomousDistance.java. On lines 18-22, we \nuse the new keyword to create four Command objects to send to addCommands. A DriveDistance \ncommand, a TurnDegrees command, another DriveDistance command, and finally, one last TurnDegrees \ncommand. These four commands are declared inline and sent straight to addCommands. That is literally \nall that has to be done to create this command group – simply creating and adding the commands, and \nthe CommandScheduler takes care of the rest, because for each of the commands, they have isFinished \nmethods that can tell when they finish. \n</p>"
            },
            "18": {
                "actionType": "Code",
                "content": "<p> \nThis makes command groups easy to create and modify. Let’s try it out. See if you can add a \ncouple more commands to AutonomousDistance. The only thing to watch out for is that on line 22, \nthere is an extra “)”, which closes the “(“ on line 18, and also a semicolon. You can add commands in-\nbetween the existing commands or at the end, just ensure that the overall addCommands method call \nstill ends with “);” after the last command that is added. You’ll also need to add commas after each new \ncommand you add. Here’s an example of adding a couple more commands: \n</p>",
                "image": "<img src=\"./images/lesson10_7.png\"/>"
            },
            "19": {
                "actionType": "Code",
                "content": "<p> \nTry playing around and making a few auto routines of your own. You can also delete the existing \ncommands and change the robot’s speed. Note that if the robot’s wheels slip on the surface you’re \ndriving on, it will make the sensors’ readings of how far you’ve driven or rotated inaccurate. For practice \nexercises, try the following: \n<ol><li>Drive the robot in a square with 12-inch sides. </li><li>Drive the robot in the shape of an equilateral triangle with 9-inch sides. </li><li>Drive the robot in a + shape, of a size of your choosing. </li><li>Be creative and make your own path! </li></ol></p>"
            }
        },
        "Wrap-Up": {
            "20": {
                "actionType": "Read",
                "content": "<p>Through these ten lessons, you’ve learned a lot about both programming robots and writing \nsoftware using Java as the programming language. You now know enough to modify programs to write \nand modify basic programs. You can add your own commands and edit existing functionality. You’ve \nlearned how to access different systems on the Romi such as the drivetrain, the LEDs, and the \ngyroscope, and how to interface with your controller and its joysticks and buttons. There’s still a lot to \nlearn, and in the next course we’ll dive deeper into some of the concepts we had to gloss over in this \none, such as the “extends” keyword, the @Override tags, and how to build up your own programs from \nscratch. But if you’ve made it this far, you are well on your way to becoming an advanced programmer. \nTake a moment to be proud of what you’ve learned so far and feel free to spend some time having fun \nwith the Romi. Don’t be afraid to modify anything you find in the code and see what happens. Worst \ncase, you can always create a new RomiReference project from scratch and start over! When you’re \nready, you can dive into Course 2 and continue your learning. \n</p>"
            }
        },
        "totalParagraphs": 21
    },
    "Lesson 11 - Logical Operators": {
        "Introduction": {},
        "Logical Operators": {
            "0": {
                "actionType": "Read",
                "content": "<p>You’ve worked with if statements in a few lessons already and seen how they can be useful for \nhaving code run or not run based on conditions that arise. Often these conditions are simple – for \nexample, if a button pressed, drive in cut power. However sometimes you might have more complicated \nconditions. Let’s revisit your project from lesson 9, DriveStraight, for an example of this. In the \nDriveStraight project, you added an if statement to line 50 of Drivetrain.java to update the target \nheading if the user was turning the robot: \n</p>",
                "image": "<img src=\"./images/lesson11_0.png\"/>"
            },
            "1": {
                "actionType": "Read",
                "content": "<p> \nThis if statement allowed you to turn the robot and also have your orientation-correcting code \nrun, however, it resulted in jerky behavior because it would stop updating the heading immediately \nafter turn joystick stopped registering, even though the robot still had angular momentum meaning the \nturn was not yet finished yet. We could solve for this problem with a slightly more refined if statement: \nif the user is actively turning the robot, or there’s an existing turn that is still finishing, update the target \nheading. In this sentence, the word “or” is a logical operator. We can use it in an if statement, and if \neither of the conditions surrounding the “or” or true, the if statement returns true. There are a number \nof logical operators in Java, but we’ll focus on three main ones: and, or, and not. \n</p>"
            },
            "2": {
                "actionType": "Read",
                "content": "<p>All three operators are simple enough to understand and use, although you can create complicated logical conditions by combining them. For now let’s focus on basics. The and operator will return true if both conditions it checks are true, and is represented by two ampersands, or “&&”. If either condition is false, the and statement will return false. Example: </p>",
                "image": "<img src=\"./images/lesson11_1.png\"/>"
            },
            "3": {
                "actionType": "Read",
                "content": "<p>The or operator will return true if either of the conditions it checks are true. It will also return true if both of the conditions are true. As long as one of the conditions is true, it does not matter if the other conditions are true or false. The or operator is represented by two “pipes”, or “||”.  Example:  </p>",
                "image": "<img src=\"./images/lesson11_2.png\"/>"
            },
            "4": {
                "actionType": "Read",
                "content": "<p>The not operator will return true if and only if the condition it’s checking is false. So it simply returns the opposite of whatever condition it checks. The not operator is represented by a “bang”, or exclamation point (!). Example:  </p>",
                "image": "<img src=\"./images/lesson11_3.png\"/>"
            },
            "5": {
                "actionType": "Read",
                "content": "<p>Different people and different organizations have different feelings on using the not operator. \nSome people prefer to check if a value is equal to false over using the not operator because they \nfind it easier to read. Here’s an example of the same if statement, but without the not operator: \n</p>",
                "image": "<img src=\"./images/lesson11_4.png\"/>"
            },
            "6": {
                "actionType": "Read",
                "content": "<p>Regardless of your, your teacher’s, or your future employer’s opinion on this, you’ll need to \nunderstand the not operator. You’ll also see it used in combination with an equal sign to \nrepresent “not equal to”. Here’s an example of that: \n</p>",
                "image": "<img src=\"./images/lesson11_5.png\"/>"
            },
            "7": {
                "actionType": "Read",
                "content": "<p>You can also combine these operators. You can group conditions together using parentheses to \nmake sure the operators work on exactly the text you want them to. Here’s an example: \n</p>",
                "image": "<img src=\"./images/lesson11_6.png\"/>"
            },
            "8": {
                "actionType": "Read",
                "content": "<p>There is no limit to how many clauses you could put in a single if statement, although you don’t \nwant to overdo it because if you do your code will become difficult to follow. You can split individual \nconditions out into boolean variables on their own line to simplify things a bit. Example: \n</p>",
                "image": "<img src=\"./images/lesson11_7.png\"/>"
            },
            "9": {
                "actionType": "Read",
                "content": "<p>When using boolean variables, such as “morning” and “dateIsTenthOrFifteenth” previously, you don’t need to use the == operators – you can simply use the variables since they evaluate to true/false already. Again, different people have different opinions on whether this makes the code more or less readable, but you need to be able to understand it either way. Here’s the final if statement from before but stylized differently. This has exactly the same meaning as the final if statement from the example above:  </p>",
                "image": "<img src=\"./images/lesson11_8.png\"/>"
            },
            "10": {
                "actionType": "Read",
                "content": "<p>And lastly, you can use the evaluation of a statement to set the value of a boolean variable, without \nusing if statements. The same warning about opinions on way to structure code applies. Here’s an \nexample. Note the difference between the single = sign being used to assign a variable a value, and the \ndouble == signs being used to evaluate an expression. \n</p>",
                "image": "<img src=\"./images/lesson11_9.png\"/>"
            }
        },
        "The DriveStraight Project": {
            "11": {
                "actionType": "Read",
                "content": "<p>Now that you understand what logical operators are and how they can be used to create \ncompound conditions, let’s fix that issue with the DriveStraight project. Right now, our condition is “the \ndriver is pressing on the turning joystick”, but we really want a condition along the lines of “the driver is \npressing on the turning joystick or they were very recently pressing on the turning joystick, and that turn \nhasn’t finished yet.” The second clause of that statement covers the time between when the driver \nreleases the joystick, and the turn completes. But how do we actually write that in code? There are \ndifferent ways one could go about defining that. We’ll use a fairly simple one and just use a timer to \ncheck how much time has passed since the driver released the joystick. Presumably, the turn will finish \nwithin some fairly small amount of time after they release the joystick. If the drive straight code is off for \na fraction of a second after the turn finishes, it’s not a big problem, so we don’t need to worry about our \nestimate for the time being slightly off. \n</p>"
            }
        },
        "The WPILib Timer Class": {
            "12": {
                "actionType": "Code",
                "content": "<p>The WPILib has a built-in Timer class you can use for timing things in your code. The capabilities \nof this class are fairly straightforward – you declare a Timer object, and you can start it, stop it, check \nhow much time has elapsed, and reset it to zero. In your DriveStraight project, open Drivetrain.java, and \nafter you declare your targetHeading variable on line 19, add a new line and declare a Timer object \ncalled “turnTimer”. You’ll get a red line under Timer, so use the lightbulb to import the Timer class from \nedu.wpi.first.wpilibj. This is important because there are other Timer classes that you’ll see which are \nbuilt in to the Java programming language, but we want the WPILib one. You can initialize your Timer in \nthe same line you declare it: \n</p>",
                "image": "<img src=\"./images/lesson11_10.png\"/>",
                "more_images": "<img src=\"./images/lesson11_11.png\"/>"
            },
            "13": {
                "actionType": "Code",
                "content": "<p> \nIf you create a new line on line 52 and type “turnTimer.” You’ll get a dropdown of various Timer \nmethods you have access to. You can scroll through this to see the various capabilities of the Timer \nclass. This is good for seeing what’s available to you, but delete this line for now. The methods we’re \nmost interested in for the timer are start, stop, and reset. Resetting the timer is important because if we \ndon’t reset it after each turn, then the next time the user turns, the grace period we check for using the \ntimer will have already elapsed because the timer started from a value above the grace period, instead \nof starting from zero. \n</p>",
                "image": "<img src=\"./images/lesson11_12.png\"/>"
            },
            "14": {
                "actionType": "Read",
                "content": "<div><p>There are a few conditions we need to think about in order to make this work. First off, is the  user turning? If so, we need to update the heading. We also need to reset the timer constantly when  this is true, because we want to start the grace period from when the user releases the joystick, not  from when they first press it. The amount of time they hold the joystick down for varies and can’t be predicted, so timing the grace period from when they first press it won’t work. Another important  condition is, is the user done turning but the time is within the grace period? If so, we want to continue updating the heading, but we do NOT want to reset the timer, because now we need to time the grace  period.  Lastly, we want to know if the timer is higher than the grace period value, because if it is, we  consider the turn to be finished. In this case we want to stop updating the heading, stop the timer, and reset the timer for future use. Here are the conditions in a list: </p><ul><li>Is the user turning? -> Update the heading, reset the timer, and start the timer</li><li>Is the user NOT turning, BUT the timer is within the grace period? -> Update the heading but DO NOT reset the timer</li><li>Is the user NOT turning, AND the timer is greater than the grace period? -> Do NOT update the heading, but DO reset and stop the timer.</li></ul></div>"
            },
            "15": {
                "actionType": "Read",
                "content": "<div><p>There are a number of different ways you can implement these conditions in your code, and there isn’t necessarily a single right way to do it. A good way to approach it is to identify three key boolean variables:</p><ul><li>Is the user turning?</li><li>Is the timer within the grace period?</li><li>Does the heading need to be adjusted <i>specifically because of the timer?</i></li></ul></div>"
            },
            "16": {
                "actionType": "Code",
                "content": "<p>In your arcadeDrive method, try creating these three boolean variables. Note that for the third \none you need to check if the timer is in the grace period, but you also need to check that the timer is \ngreater than zero, because the timer starts at zero. This means that even if the user has never turned, if \nyou simply check that the timer is less than the grace period, it will return true and your code will \nupdate the target heading all the time, even when not turning. This would result in your code never \ncorrecting the robot’s heading because it will always set the target heading to the robot’s current \nheading. This means you have two conditions to check – that the timer is within the grace period and \nthat the timer is greater than zero. This is a chance to try out using the and operator. For the grace \nperiod, create a constant in Constants.java. You can play around with values to see what works best. A \ngood starting point is .5 seconds. Here’s an example of creating these three variables: \n</p>",
                "image": "<img src=\"./images/lesson11_13.png\"/>"
            },
            "17": {
                "actionType": "Code",
                "content": "<p>With these three variables, you can now look back at the list of conditionals (the first list of \nbullet points in this section) and create all the necessary if statements. Give it a try, using the variables \nand logical operators to emulate the logic described. Inside the if statements, put the necessary logic. \nThe only lines you need inside the statements are lines to start/stop/reset the gyro (turnTimer.start(), \n.stop(), and .reset(), respectively) and the line to update the targetHeading. When you’re done your \ncode might look something like this: \n</p>",
                "image": "<img src=\"./images/lesson11_14.png\"/>"
            },
            "18": {
                "actionType": "Code",
                "content": "<p> \nWhen you’ve done this, it’s time to test your code. With the code you’ve previously written in \nthis method, your completed method might look something like this: \n</p>",
                "image": "<img src=\"./images/lesson11_15.png\"/>"
            },
            "19": {
                "actionType": "Read",
                "content": "<p> \nGo ahead and deploy this and let’s test it out! \n</p>"
            }
        },
        "Testing the Code": {
            "20": {
                "actionType": "Robot",
                "content": "<p>Let’s talk briefly about how to test robot code. As we do more advanced projects, testing \nbecomes more and more important because it’s often easy to make a mistake with your code and not \nnotice it the first time you run your program. You want to test your code in as many situations as \npossible to make sure you’re not missing anything. There is a lot of thought and research dedicated \nspecifically to testing, but for today we’ll just cover some basic concepts. First, you want to test as many \nedge cases as possible. The definition of an edge case changes slightly depending on the context, but in \ngeneral, it’s a situation that is rare and exists near the “boundaries” of your logic. For example, say you \nhad an if statement that changes the behavior of your program if some variable is greater than 100. \nSome edge cases to check would be when the variable is 99 (clearly not greater than 100), 100 (also not \ngreater than 100, but might return true if you accidentally used “greater than equal to” in your code \ninstead of greater than), and 101, which is clearly greater than 100. For the program we’re working with \nright now, some edge cases would be to make sure that the robot works if you never turn it (e.g. to put \nit back on the tray and rotate it around, and to make sure it maintains its orientation),  to make sure it \nworks if you turn it very briefly, to make sure it works if you turn it for an extended period of time, and \nto make sure it still passes the tray test after you turn it. \n</p>"
            },
            "21": {
                "actionType": "Code",
                "content": "<p> \nAnother concept in testing is to add outputs to your program so you can see what is happening \nin real time. Outputs can take various forms. When we turned on an LED based on the robot’s \norientation, that was an output in a literal sense – something we can see that gives us feedback on \nwhat’s going on. Other outputs are all the data you see on the Robot Simulation interface. In this case, \nlet’s add a System.out.println() to get output in the terminal. A key variable for this program is the timer. \nIf you output the timer’s value after your if statements, you will be able to see the value in the terminal \nwhile you run your program: \n</p>",
                "image": "<img src=\"./images/lesson11_16.png\"/>"
            },
            "22": {
                "actionType": "Read",
                "content": "<p>Doing this allows you to check and see that your timer is starting whenever you stop turning, and \nresetting after it hits your Constants value. You can use this to check that everything is behaving as you \nexpect based on the value of this variable. If your code doesn’t work right after you deploy it, this will be \na good trick to debug and figure out where your mistake is. \n</p>"
            },
            "23": {
                "actionType": "Code",
                "content": "<p> \nBut let’s say your code does work immediately after you deploy it. That’s good, but it can \nsometime lead to confusion of its own – why does the code work? Did you do everything correctly and \nyou’re now done, or are you not testing all of the cases? If you add your SOP line, you can help confirm \nthat everything is correct. You can also test this by changing things to make it incorrect and then \nconfirming that your code no longer works, before reverting the change. Let’s try that. You declared a \nconstant for the grace period for turning. What if we change the value of that constant? Try a few \ndifferent values. If you set it to .05, that will be too short and you should be able to observe the same \njerky behavior after turning. If you set it to 5, there will be a delay of several seconds after you finish \nturning before the timer finishes, and you can observe this in the terminal as you watch your timer \nincrease in value to 5 before resetting. During this time you should be able to physically move your \nrobot (pick it up, rotate it, and set it back down within the 5 seconds.) It will not correct its position \nduring this time because it’s still in the turning grace period. If you observe these behaviors when you \ntest, but you do not observe them when you set the grace period value back to something reasonable \nlike .5, then you can be confident your code is working. \n</p>"
            }
        },
        "Tidying Up": {
            "24": {
                "actionType": "Search",
                "content": "<p>At this point, you could be done with the project, but there’s a little bit of room for optimization \nand also another chance to practice your logical operators. Right now, we have two conditionals that \nboth update the target heading: \n</p>",
                "image": "<img src=\"./images/lesson11_17.png\"/>"
            },
            "25": {
                "actionType": "Code",
                "content": "<div><p>Although there are exceptions, duplicated lines in if statements are often an indicator that you  could optimize your code. If we rephrase our conditional slightly, we can eliminate this. Try writing three  if statements using the following conditions:</p><ul><li>If the user is turning, reset and start the timer</li><li>If the user is turning OR you need to adjust the heading due to the timer, update the heading</li><li>If the timer is greater than the grace period, stop and reset the timer</li></ul><p>After you do this, your conditionals might look something like this:</p></div>",
                "image": "<img src=\"./images/lesson11_18.png\"/>"
            },
            "26": {
                "actionType": "Robot",
                "content": "<p> \nNotice how not only did you shave one line of code off of your program, but there’s less text \noverall. In software development, less is usually better, because the more code you have, the more \nwork you have to do to read through it, test it, make changes, etc. Less is good. Once you’ve made \nthese changes, test your code (with or without the SOP statement), and when it works, you’re done! \n</p>"
            }
        },
        "totalParagraphs": 27
    },
    "Lesson 12 - Inheritance & Polymorphism": {
        "Introduction": {
            "0": {
                "actionType": "Read",
                "content": "<p> \nIn this lesson we’ll focus on a couple more critical OOP concepts, and finally cover the keyword \n“extends”, which you’ve seen when working with commands but haven’t had explained to you yet. We’ll \ndo a quick review of a few classes in your RomiReference project so you understand how the concepts \nrelate, and then do a desktop project without the Romi to get some practice. \n</p>"
            }
        },
        "Composition, Inheritance, & Polymorphism": {
            "1": {
                "actionType": "Read",
                "content": "<p>There are three main concepts to cover right now: composition, inheritance (extension), and \npolymorphism. \n</p>"
            },
            "2": {
                "actionType": "Search",
                "content": "<p><i>Composition</i> is pretty simple and you’ve already seen a number of examples of it. It’s the idea that classes can be composed of other classes. You use this every time you declare an object of as a class field in an object of another type. For example, here’s a snippet from the Drivetrain class in lesson 11:  </p>",
                "image": "<img src=\"./images/lesson12_0.png\"/>"
            },
            "3": {
                "actionType": "Read",
                "content": "<p> \nAmong other objects, the Drivetrain class is composed of a Timer object and two Spark objects, \nrepresenting the timer we use for driving straight, and the left and right motors. Composition is simple \nbut powerful as it allows for complexity to be broken into simpler pieces, and for code reusability as \nclasses tend to be self-encapsulated units that can be used in more than one place. \n</p>"
            },
            "4": {
                "actionType": "Search",
                "content": "<p><i>Inheritance</i> is the idea that you can define a class (called a “subclass” or “child” class) which has all the characteristics of its “parent” class, and then additional characteristics as well. If you have a lot of classes which share common functionality, this is useful, because that way you don’t need to re-write the same functionality. You’ve already used inheritance too although you probably haven’t realized it. Every time you see the keyword <i>extends</i>, you’re using inheritance. A class that extends another class,  inherits attributes from that class. In the last image, Drivetrain extends SubsystemBase. SubsystemBase is a class the CommandScheduler recognizes as a subsystem. So when Drivetrain extends SubsystemBase, Drivetrain is also recognized as a subsystem, which allows you to run commands that require it, such as the autonomous commands you wrote in lesson 11 and also the ArcadeDrive command. Drivetrain also literally does extend the SubsystemBase class, because you add a  bunch of functionality. When you need a Drivetrain class, you need a Drivetrain class – not any random Subsystem. If you got some SubsystemBase object that didn’t have, for example, left and right motors, it wouldn’t do you any good.</p>"
            },
            "5": {
                "actionType": "Read",
                "content": "<p><i>Polymorphism</i> is a fancy word for an important concept. It basically means that an object of a certain class can exist as a few different kinds of objects. Let’s again use our subsystems and commands as examples. The CommandScheduler runs your commands by calling their execute method constantly. It knows that it’s calling the execute method of a command. However it does not know if it’s calling the execute method of an ArcadeDrive command, a DriveDistance command, a TurnDegrees command, or something else. From its point of view, it’s simply calling the execute method of a Command object. In reality that Command object might be of any of the types of command just listed, or something different. This is polymorphism: all the different types of commands are each, well, commands, and so a generic Command object could end up being any of those types, and that’s fine since they all have the same initialize, execute, end, and isFinished methods. This will make more sense as you see more examples of it.</p>"
            },
            "6": {
                "actionType": "Code",
                "content": "<p>That’s a brief introduction to these concepts. For a deeper study including lots of examples of code, read sections 1-4 (NOT 1.1-1.4, the full sections 1-4) on this page. You may want to open the code in a desktop app in VSCode and follow along, since the text portion is fairly short and they rely on code examples: <a href='https://www3.ntu.edu.sg/home/ehchua/programming/java/J3b_OOPInheritancePolymorphism.html'>https://www3.ntu.edu.sg/home/ehchua/programming/java/J3b_OOPInheritancePolymorphism.html</a></p>"
            }
        },
        "Examples in the RomiReference Project": {
            "7": {
                "actionType": "Search",
                "content": "<p>Now that you’ve learned more about these concepts, let’s see how they apply to our robot \ncode. Open a default RomiReference project, open DriveDistance.java, and look at line 10. You’ll see the \ntext “extends CommandBase”. You learned before that the extends keyword is how Java knows your \ncommand is actually a command, and now you understand why. CommandBase is a command, so any \nclass that extends CommandBase is also a command. A command is defined as having the four methods \nwe’ve talked about – initialize, execute, isFinished, and end – so DriveDistance has these methods, and \nthey’re tagged with @Override as explained in the reading. We’ll talk about how a command is defined \nas having these four methods in an upcoming lesson. \n</p>"
            },
            "8": {
                "actionType": "Search",
                "content": "<p> \nThere are numerous similar examples in the RomiReference object but let’s look at just one \nmore. Open Robot.java. In a previous lesson you learned about how there are methods in this class that \nrun constantly depending on what mode the robot is in (disabled, teleoperated, etc.) There’s also the \nrobotPeriodic() method that runs all the time regardless of which mode you’re in. Why do these \nmethods run all the time? Look at line 17 where the class is defined: \n</p>",
                "image": "<img src=\"./images/lesson12_1.png\"/>"
            },
            "9": {
                "actionType": "Search",
                "content": "<p> \nThe Robot class extends TimedRobot. If you click on TimedRobot and press F12, you’ll be taken \nto the class definition for TimedRobot. You’ll notice that TimedRobot extends IterativeRobotBase: \n</p>",
                "image": "<img src=\"./images/lesson12_2.png\"/>"
            },
            "10": {
                "actionType": "Read",
                "content": "<p>This is a good example of how you can make a <i>hierarchy</i> by extending classes. Your Robot class extends TimedRobot, which extends IterativeRobotBase. Therefore your Robot class is a TimedRobot, and is also an IterativeRobotBase. This allows you to go from general to specific. In the case of the Romi, the general classes are all written for you and wouldn’t modify them unless you’re doing something quite advanced. When you write your own programs from scratch, you’ll create your own hierarchies.</p>"
            },
            "11": {
                "actionType": "Search",
                "content": "<p>For now, if you once again F12 on IterativeRobotBase, you’ll again be taken to a class definition. \nIn this file, you can ctrl-f and search for “periodic”, and you’ll find all of the period methods we were just \ntalking about. Don’t worry about most of the code you see in this file, but let’s take one quick peek at \nthe teleopPeriodic() method: \n</p>",
                "image": "<img src=\"./images/lesson12_3.png\"/>"
            },
            "12": {
                "actionType": "Search",
                "content": "<p>On line 182, as shown in the previous image, you’ll notice there’s an SOP saying “Override me!”. When the people writing the WPILib were making these general classes that get extended, they included this line so that if you run code without realizing you need to override these periodic methods, when you run your code the default, or super, method will be called and it will tell you to override it. In the RomiReference project these methods are already overridden – in this case on line 85 of Robot.java – but this is just an example of how the hierarchy works. Looking through the code like this gives you a deeper understanding of exactly how your Java program works.</p>"
            }
        },
        "RobotComposition Project": {
            "13": {
                "actionType": "Read",
                "content": "<div><p>When modifying an already-existing RomiReference project, most of the hierarchy work is already done for you. It’s important to understand it, and when doing advanced work with your robot you will even add to it. However, for solidifying your understanding of these concepts, it’s best to make your own hierarchies from scratch, so we’ll do a desktop project for this lesson. In this project you’ll create the hierarchy for defining robots that can participate in various FIRST Robotics Competition (FRC) games. If you aren’t familiar with FRC, here are some links to YouTube videos that show how the games work. FRC robots are programmed using the same exact WPILibrary that you’re using to learn programming, so if you have the opportunity to join a team at your school or in your community, not only will you have bigger and stronger robots to play with than the Romi, but you’ll already be ready to dive right into programming them. Here are the videos for the 2018, 2019, and 2020 editions of the competition. Pay attention to the possible different mechanisms on the robots. They all have drivetrains, along with other mechanisms that depend on the robot and the game. Some robots might have elevators, some might have ball shooters, and some might have climbers. You don’t need to worry about the point values</p><ul><li>2018, Power Up: <a href='https://www.youtube.com/watch?v=HZbdwYiCY74'>https://www.youtube.com/watch?v=HZbdwYiCY74</a></li><li>2019, Destination: Deep Space: <a href='https://www.youtube.com/watch?v=Mew6G_og-PI'>https://www.youtube.com/watch?v=Mew6G_og-PI</a></li><li>2020, Infinite Recharge: <a href='https://www.youtube.com/watch?v=gmiYWTmFRVE'>https://www.youtube.com/watch?v=gmiYWTmFRVE</a></li></ul></div>"
            },
            "14": {
                "actionType": "Read",
                "content": "<div><p>Now that you’ve seen the games, let’s define a hierarchy for <i>composing</i> some robots in code. For the sake of this project, we will assume that robots from the following games have the following types of manipulators. All robots will have drivetrains:</p><ul><li>Power Up: a climber and an elevator.</li><li>DeepSpace: a climber and an elevator.</li><li>InfiniteRecharge: a climber and ball shooter.</li></ul></div>"
            },
            "15": {
                "actionType": "Code",
                "content": "</p><ol><li>Create a new desktop project called RobotComposition and then create the following classes: RobotComposition (which will contain your main method), Robot, Drivetrain, GamePieceManipulator, CubeElevator, BallShooter, HatchPanelPlacer, PowerUpRobot, DeepSpaceRobot, InfiniteRechargeRobot</li><li>In your robot class, define two protected class fields, called “drivetrain” and “manipulator”. Make their variable types “Drivetrain” and “GamePieceManipulator”, respectively. We haven’t  talked about protected, but it is in between public and private. With protected variables, other  classes cannot access them, but subclasses can, making them handy for use when creating  hierarchies.  </li><li>In your PowerUp, DeepSpace, and InfiniteRecharge robot classes, use the extends keyword to make these classes inherit from the class “Robot”. We will refer to these three classes – but not  Robot itself - as “game robot classes”.</li><li>Make your CubeElevator, HatchPanelPlacer, and BallShooter classes extend the class “GamePieceManipulator”. We will refer to these three classes – but not GamePieceManipulator  itself - as “manipulator classes”.</li><li>In each of your game robot classes, create a constructor method that has no parameters. Inside your constructor, create an object of the class of the manipulator that best corresponds to that game. Then set the game robot’s manipulator class field <i>(which it inherited from Robot, and therefore you don’t see in the code file you’re looking at)</i>, to the newly created object. Note how the “manipulator” variable is of type GamePieceManipulator, but across our three game robot classes, we were able to set it equal to objects of three different classes. That is because all of these classes, despite being different from each other, are still GamePieceManipulators.</li></ol></div>"
            },
            "16": {
                "actionType": "Code",
                "content": "<p>Example: DeepSpaceRobot constructor. Note how we can set this.manipulator, despite it not \nbeing defined inside of the file. \n</p>",
                "image": "<img src=\"./images/lesson12_4.png\"/>"
            },
            "17": {
                "actionType": "Code",
                "content": "<div><p>6. Go into GamePieceManipulator and create a method called “manipulate” that SOP’s s message.</p><p>7. Go into Robot and create a method called “manipulateGamePiece calls the manipulator.manipulate() method.</p><p>8. In your main method, create a robot object and a GamePieceManipulator object. Set the Robot object’s manipulator variable equal to your newly created GamePieceManipulator object. Then call your robot’s manipulateGamePiece method. Now is a good chance to run your code and check that everything is working – if it is, you’ll see the SOP line you added to  GamePieceManipulator.manipulateGamePiece get called and you’ll see the output in your terminal.</p></div>",
                "image": "<img src=\"./images/lesson12_5.png\"/>"
            },
            "18": {
                "actionType": "Code",
                "content": "<div><p>9. Go into your three manipulator classes and create manipulate() methods there. These methods should output something identifying what kind of manipulator they are, e.g. “now shooting power cells.”</p><p>10. In your main method, create three new objects, one for each type of robot.</p><p>11. Call the manipulateGamePiece method for each of your robot objects. Example:</p></div>",
                "image": "<img src=\"./images/lesson12_6.png\"/>"
            },
            "19": {
                "actionType": "Read",
                "content": "<p>You will have four lines of output, each of which is a message describing a type of manipulator. \nNote a couple things: \n</p>"
            },
            "20": {
                "actionType": "Read",
                "content": "<p>1. We defined a “manipulate” method for Robot.java so all robots can “manipulate’, even if \nthe output is generic. \n</p>"
            },
            "21": {
                "actionType": "Read",
                "content": "<p>2. We overrode “manipulate” in our manipulator subclasses, so when we called .manipulate() \nin Robot.java, it was able to perform more specific functionality. (Polymorphism.) \n</p>"
            },
            "22": {
                "actionType": "Read",
                "content": "<p>3. In Robot.java, we created a manipulateGamePiece() method, which we never overrode. \nSince we extended Robot.java with our robot classes, they already had access to the \nmanipulateGamePiece() method, despite us never defining it in those classes. \n</p>"
            }
        },
        "totalParagraphs": 23
    },
    "Lesson 13 - Arrays": {
        "Introduction": {
            "0": {
                "actionType": "Read",
                "content": "<p><i>Note: there is no included solution program for lesson 13.</i></p>"
            },
            "1": {
                "actionType": "Read",
                "content": "<p> \nFor this lesson we’ll step back from object-oriented programming for just a bit and go back to \nsome more basic syntax/variable/data stuff. Specifically, arrays, and the “ArrayList” syntax. The concept \nof arrays is general to most programming languages, but “ArrayList” is specific to Java. Other languages \nhave similar constructs. \n</p>"
            },
            "2": {
                "actionType": "Read",
                "content": "<p> \nAn array is a set of variables of the same type. For example, you could make an array of days \nthat has seven items, and call it a week. Or you could make an array of months with 12 objects, and call \nit a year. \n</p>"
            },
            "3": {
                "actionType": "Read",
                "content": "<p> \nOf course, you could create whatever variables you want to create without putting them in an \narray. For example, if you had a class called “Day” and you wanted to make a week, you could declare \nseven different Day objects, and you could call them monday, tuesday, etc. However, arrays let you \ngroup objects together and perform operations on the set. For example, you could write a for loop that \ndoes some action on every item in an array. For example, in our week array, it could output the weather \nfor each day. If you have a bunch of individual variables you declared that aren’t grouped, this would be \ndifficult or even impossible. For example, you could write seven lines to output the weather for each day \nof a week, since every week has seven days. But imagine trying to do this for a month. Not only would \n31 lines of output be awful to write, but some months don’t even have 31 days. The code might work for \nJanuary but you’d get an error when you tried to output the 30th day of February. \n</p>"
            },
            "4": {
                "actionType": "Code",
                "content": "<div><p>Read through the following page for how to create and use arrays:  <a href='https://www.tutorialspoint.com/java/java_arrays.htm'>https://www.tutorialspoint.com/java/java_arrays.htm</a> Pay careful attention to the “processing arrays” section as this shows you how to access individual elements and use the .length property of the array to set up a for loop. You can use the syntax to access an index or an array both to read values and to update them. Array Exercises</p><ol><li>Create an integer array with 70 values called “testScores”. Populate the array with values; it doesn’t matter what the values are. (You may want to use a loop to do this.)</li><li>Write a loop that calculates and outputs the mean value of the test scores.</li><li>Write a foreach loop that outputs every value in the array.</li><li>Create a new integer array, also with 70 values, called “testScoresWhenYouDontStudy”. Copy the values from “testScores” into your new array, but subtract 25 from each value.</li><li>Create an array of seven strings called “days” that has each day of the week as a variable. Output this array using a for loop.</li></ol></div>"
            }
        },
        "ArrayLists": {
            "5": {
                "actionType": "Read",
                "content": "<p> \nIn Java, arrays are useful but have some limitations. They are of a fixed size, which means that \nonce you create them, you can’t change how big they are. This sometimes isn’t an issue – for example, if \nyou’re trying to keep track of days in a year, you can know that ahead of time and declare your array to \nbe 365 items. However, for some things it’s problematic. Say you have a program that calculates a \nstudent’s grade by simply calculating the mean of all their assignment scores. Every time a new \nassignment is graded, that score gets added to the array. You decide to store all the scores in an array, \nbut it’s impossible to know how many scores there are going to be ahead of time. In this situation, every \ntime you want to make the array bigger, you would need to declare a new array of a larger size, copy the \nold array into the new array, and delete the old array. An alternative to this is to use Java’s ArrayList, \nwhich is basically a convenient wrapper for the basic array syntax. The ArrayList is going to do the \nactions just described, but it will do it behind the scenes so you don’t have to manually do it yourself. \n</p>"
            },
            "6": {
                "actionType": "Read",
                "content": "<p> \nThe following page shows the syntax for setting up ArrayLists. ArrayLists are objects so you will \nuse methods on them, e.g. .size() and .get(), instead of just calling .length or accessing an index directly. \nYou don’t need to memorize all of these methods just yet, but you should at least read through the page \nuntil you get to the part where it says “Collections.min, max.” The most basic methods – size, get, set – \nyou do need to know. Note how they use “<” and “>” as part of the syntax. This is kind of weird, but \ndon’t worry about it for now. Just go with it and put an object type in between. In this case we’ll use \n“Integer”.  \n</p>"
            },
            "7": {
                "actionType": "Code",
                "content": "<p>You might wonder why we use the word “Integer” instead of “int”, which we use to declare  integer variables. Don’t worry about this for now – just know that Java will automatically convert  between “int” and “Integer”. <a href='https://www.dotnetperls.com/arraylist-java'>https://www.dotnetperls.com/arraylist-java</a></p>"
            },
            "8": {
                "actionType": "Code",
                "content": "<p>ArrayList Exercises: now, do the array exercises from earlier in the lesson, but use ArrayLists instead of arrays.</p>"
            }
        },
        "Two-dimensional Arrays": {
            "9": {
                "actionType": "Code",
                "content": "<div><p>A two-dimensional array is basically an “array of arrays”. If instead of making an array of integers, you made an array of <i>arrays of integers</i>, you would end up with, essentially, a square or grid of integers. For example, you could make an 8x8 two-dimensional array to represent a chessboard. In Java, 2d arrays don’t actually need to be squares. The first dimension must have some length – how long your array of arrays is – but the second dimension, the length of <i>each array within the array</i>, can vary. Read through this link for some examples and the syntax for how to set these up. <a href='http://www.java67.com/2014/10/how-to-create-and-initialize-two-dimensional-array-java-example.html'>http://www.java67.com/2014/10/how-to-create-and-initialize-two-dimensional-array-java-example.html</a></p><p>Two-Dimensional Array Exercises</p><p>1. Create a 10x10 array of integers, and populate it with the numbers 1 to 100. Then print the array, with a new line after each multiple of 10. So your output should look as follows:</p><p>1 2 3 4 5 6 7 8 9 10</p><p>11 12 13 14 15 16 17 18 19 20</p><p>etc.</p><p>2. Create an 8x8 “chessboard”, by making a 2d array of Boolean values. For this, the value “true” will represent a black square, and “false” will represent a black square. Then output the results. It should look as follows:</p><p>false true false true false true false true</p><p>true false true false true false true false</p><p>etc.</p></div>"
            }
        },
        "totalParagraphs": 10
    },
    "Lesson 14 - Abstract Classes & Interfaces": {
        "Introduction": {
            "0": {
                "actionType": "Read",
                "content": "<p>In this lesson we will just about finish up with object-oriented programming. There will be a couple small things left to cover in lesson 15 but you’re almost done. The two big topics in this lesson are <b>abstract classes</b> and <b>interfaces</b>. Both of these concepts are somewhat similar to what you learned in the inheritance lesson, but they have slightly different use cases.</p>"
            },
            "1": {
                "actionType": "Read",
                "content": "<p>One quick note – a class can only inherit from, or extend, one class. E.g. you can’t do class Dog \nextends Animal, extends Pet, etc. You have to choose one. \n</p>"
            },
            "2": {
                "actionType": "Code",
                "content": "<p>Watch this video – it does a good job of explaining abstract classes. Pay close attention to the example with the array at the end. Being able to group different kinds of objects together and perform operations on all of them because it’s known they extend the same base class is critically important. This ability to group things based on parent class (or interface) is one of the biggest advantages to using inheritance, abstract classes, and interfaces, as opposed to just typing out the methods, but NOT creating the parent class/abstract class/interface. Here’s the video: <a href='https://www.youtube.com/watch?v=pt1S11yX-7k'>https://www.youtube.com/watch?v=pt1S11yX-7k</a></p>"
            },
            "3": {
                "actionType": "Code",
                "content": "<p>Here’s a link to the other site we’ve been referencing’s explanation of abstract classes. It’s not bad (I think the shape example is a good one to show how sometimes you need to define that methods exist, but can’t logically be implemented in the parent class), but you’ll have to read through the code a little bit. For abstract classes, read sections 5.1 through 5.3. <a href='https://www3.ntu.edu.sg/home/ehchua/programming/java/J3b_OOPInheritancePolymorphism.html#zz'>https://www3.ntu.edu.sg/home/ehchua/programming/java/J3b_OOPInheritancePolymorphism.html#zz</a></p>"
            },
            "4": {
                "actionType": "Code",
                "content": "<p>For interfaces, watch this video: <a href='https://www.youtube.com/watch?v=NnZQ-C0x4hs'>https://www.youtube.com/watch?v=NnZQ-C0x4hs</a>  and read sections 5.4 through 5.10 of the document linked previously.</p>"
            },
            "5": {
                "actionType": "Code",
                "content": "<p>There are a few more important points about interfaces that warrant some extra explanation. \nFirst and foremost, interfaces are similar in concept to abstract classes, so if you’ve noticed some \noverlapping concepts, you’re right. But they have slightly different applications. Classes can implement \nany number of interfaces, whereas like said, they can only extend one. This is useful because classes can \nbe some individual thing, but do multiple things. For example, a class Dog might extend animal, but \nimplement “Pettable”, “CanWalk” “CanMakeNoise”, etc. In Java people often name interfaces either by \nending them with “able”, or prefacing them with “Can”. You’ll see this if you look at some of the \ninterfaces in the RomiReference project, for example the CommandScheduler class implements two \n“able” interfaces: \n</p>",
                "image": "<img src=\"./images/lesson14_0.png\"/>"
            },
            "6": {
                "actionType": "Read",
                "content": "<p>You might notice that pet, walk, and bark are all verbs. So are “send” and “auto-close”. This isn’t \na coincidence. As stated, inheritance/extension is often used to specify what something is, and \ninterfaces to designate what it can do. If you’re confused about whether inheritance or an interface is a \nbetter option for any given task, this is probably the best way to think about it. Is your class a more \nspecific instance of something, for example a dog being an animal, or is it something that can do \nsomething, but that thing isn’t necessarily related to what it is? For example, a ton of things make noise, \nbut that’s not something that is related to being a dog (or an animal.) In addition to a dog, a robot could \nalso implement a CanMakeNoise interface. (If your Romi has ever gotten low on batteries, you may have \nnoticed that it will start singing.) \n</p>"
            },
            "7": {
                "actionType": "Read",
                "content": "<p>This might sound a bit repetitive, but it’s important to understand the advantages of interfaces, \nabstract classes, and inheritance as opposed to just typing out all the methods you need in each class. \nOne big advantage is organizationally, it makes your code easier to think about and organizes your \nclasses and methods. Especially when you’re working with other people on a project, this makes life \neasier. However, it also gives you the ability to write more functional code. \n</p>"
            },
            "8": {
                "actionType": "Read",
                "content": "<p>Interfaces and parent classes (either abstract or concrete) are types that the compiler \nrecognizes. The compiler is the program that reads your code and turns it into something that a \ncomputer or robot can execute. The compiler recognizing a type lets you group by that type – for \nexample, you can make an array of GamePieceManipulator objects, even if each of those objects \nbelongs to a different class. (E.g. one belongs to “WobblyArm”, one belongs to “BrokenShooter”, etc.) \nEven if WobblyArm and BrokenShooter have the exact same methods, if you make an array of \nWobblyArm objects, you can’t add any BrokenShooter objects to that array. But by making the array of \nGamePieceManipulator objects, you can add both those types, and use all the common functionality. So \nthe interface or parent class is where you define what the common functionality is. You’ve heard the \nterm polymorphism – this is one of the prime examples. If this is confusing, go back and watch 9:04 to \n13:37 of the abstract classes video from this lesson. You’ll gain better understanding over time, but that \nat least illustrates the concept. \n</p>"
            },
            "9": {
                "actionType": "Code",
                "content": "<p>Lastly, read sections 6.1 and 6.2 here: <a href='https://www3.ntu.edu.sg/home/ehchua/programming/java/J3b_OOPInheritancePolymorphism.html#zz'>https://www3.ntu.edu.sg/home/ehchua/programming/java/J3b_OOPInheritancePolymorphism.html#zz</a></p>"
            },
            "10": {
                "actionType": "Read",
                "content": "<p>“Encapsulation” is a fancy word but the concept should look familiar (think getters and setters). \n“Coupling” is new but the explanation they give makes sense. Same with “cohesion”, but phrased \ndifferently, cohesion means that if your class shouldn’t represent multiple things – if it does, it should be \nsplit up into multiple classes until each class only represents one thing. For example you would not make \na class called “DogAndCat”, you would make a Dog class and a Cat class. \n</p>"
            },
            "11": {
                "actionType": "Code",
                "content": "<div><p>For this lesson you’ll set up classes and interfaces for a two-dimensional sprite game. We’re not  actually going to program the game (although you could do this on your own if you want), but we’ll use  it as an example of how these concepts interact.</p><ol><li>Create a new desktop Java project called “SpriteGame”. If you do this in VSCode and VSCode adds an App.java file, you can delete that file. Add the following classes:  SpriteGame (your main method will go here), Character, Enemy, Player, NPC</li><li>Create two <i>interfaces</i>. You can do this the same way you create a class – right click, add a Java file, and type in the name of the file, followed by “.java”. VSCode will default to creating a class but it will give you the option to create an interface right after you create the file. You can click  “interface” in the drop down to change it. Alternatively, simply replace the word “class” with the  word “interface” . Name your two interfaces as follows: <i>Fightable</i> and <i>Movable</i></li></ol></div>",
                "image": "<img src=\"./images/lesson14_1.png\"/>"
            },
            "12": {
                "actionType": "Code",
                "content": "<div><p>3. Let’s start by fleshing out what our interfaces do. Then we can ensure that our classes comp This is a handy way of thinking about/designing your program. Give the fightable interface the \nfollowing methods. Remember, in interfaces you just create stubs with semicolons, you don’t \nfully define the method.</p><ol><li>public void attack();</li><li>public void takeDamage(int damage);</li><li>public int getMaxHp();</li><li>public int getHpRemaining();</li></ol></div>"
            },
            "13": {
                "actionType": "Code",
                "content": "<div><p>4. Now let’s define movable. Since we’re making a 2d sprite game, “movable” just means up, down, left, and right, or x and y coordinates. Let’s make the following methods:</p><ol><li>public void moveNorth();</li><li>public void moveEast();</li><li>public void moveSouth();</li><li>public void moveWest();</li><li>public int getXPosition();</li><li>public int getYPosition();</li></ol></div>"
            },
            "14": {
                "actionType": "Code",
                "content": "<p>5. Now let’s set up our Player and Enemy classes so that they can fight each other. We have a “Character” class, and both the player and enemies are characters. So let’s make Player and Enemy extend Character. While we’re at it, make NPC do the same.</p>"
            },
            "15": {
                "actionType": "Code",
                "content": "<p>6. Right now extending Character doesn’t do much, since there’s nothing in Character. So let’s flesh that out. All characters are going to have a name, so let’s make a private String class field called “name”. Since this is private, let’s also add a method called printName that SOP’s the name field. Let’s also add a method called setName that takes a string and sets the name field.</p>"
            },
            "16": {
                "actionType": "Code",
                "content": "<p>7. Since we added a name field and a couple methods to our Character class, and Player, Enemy, and NPC all extend Character, we have access to the new Character methods in those classes. Let’s create constructor methods for these three subclasses that take advantage of this to set the name. In each of these classes, create a constructor method that takes a string and calls the setName method. <b>Protip:</b> while in a subclass, you can type “this.” to bring up an intellisense menu that includes parent class methods. So if you type “this.” in Player or Enemy, the Character class setName will appear on the menu.</p>"
            },
            "17": {
                "actionType": "Code",
                "content": "<p>8. Now that our Character class does something, let’s go to our main method in SpriteGame and write some code to test that Character is working. Create a player object, two enemy objects, and an NPC object using the constructors that set the names. You can name them whatever you want.</p>"
            },
            "18": {
                "actionType": "Code",
                "content": "<p>9. Let’s create a method that outputs the names of all our characters, even though we have different kinds of characters. To do this we’re going to need to store our characters in an accessible way. In your main method, create an ArrayList<Character> and add your four characters to it. You will need to import ArrayList from java.util.</p>"
            },
            "19": {
                "actionType": "Code",
                "content": "<p>10. Now create a method called “outputCharacterNames” that takes an ArrayList<Character> as a parameter, and prints all their names. This will be a public static void method in your SpriteGame class. (We’ll talk about static in the next lesson.) Go ahead and add a call to your new method in your main method, and confirm that it outputs three names. The method is working on objects of different classes, pretty cool!</p>"
            },
            "20": {
                "actionType": "Code",
                "content": "<p>11. Now that we have characters that are working, let’s get back to our interfaces. NPCs don’t fight, but the player and enemies do. So go into player and enemy and make them both implement Fightable. This will give you a syntax error on the class name. Mouse over and select “add unimplemented methods.” Easy! Since we’re not fully programming this game, we don’t actually care about implementing these methods for now. But, just so we can demo that they run, add a SOP to the attack() method in each that says “Now attacking.” You could go one step further and use the SOP to differentiate between the player and the enemy attacking.</p>",
                "image": "<img src=\"./images/lesson14_2.png\"/>"
            },
            "21": {
                "actionType": "Code",
                "content": "<p>12. This example illustrates how interfaces are different than subclasses. Enemies, Players, and NPCs are all characters, but they don’t all fight. So if we had put the Fightable methods inside of character, we would have a bunch of methods for NPCs that wouldn’t make any sense to call. And if we had put the Fightable methods in both Player and Enemy, we’d have code duplication.</p>"
            },
            "22": {
                "actionType": "Code",
                "content": "<p>13. Go into your main method and create another ArrayList, this time of type Fightable, and put your player and enemies in there. Make another method like you did with outputCharacterNames but instead this one calls the Fightable attack method.</p>"
            },
            "23": {
                "actionType": "Code",
                "content": "<p>14. We want our player to move, so make it implement Movable in addition to Fightable. Again, you can have VSCode implement the methods for you, in particular since we’re not going to implement them for real. Similar to how we did not make NPCs fightable, this shows how you can use interfaces to extend the functionality of certain parts of the class hierarchy, but not others.</p>"
            },
            "24": {
                "actionType": "Code",
                "content": "<p>15. Let’s do an example of how interfaces can be applied to completely unrelated classes. Create a class called “DestructibleObject”.</p>"
            },
            "25": {
                "actionType": "Code",
                "content": "<p>16. DestructibleObjects, at least in this game, are not “Characters” – they are walls, rocks, etc., that can be destroyed. So they won’t move, don’t have a name, etc., and should not inherit from Character. However, they can be destroyed, so they are Fightable. Make DestructibleObject implement Fightable and create the method stubs.</p>"
            },
            "26": {
                "actionType": "Code",
                "content": "<p>17. In the “attack” method for DestructibleObject, let’s make it a little more clear that it’s not a normal player or enemy. Instead of SOP’ing “Now attacking.”, SOP “Object destroyed!”.</p>"
            },
            "27": {
                "actionType": "Code",
                "content": "<p>18. In your main method, create a DestructibleObject object, and add it to your fightables array. Then re-run your program to see the output.</p>"
            },
            "28": {
                "actionType": "Code",
                "content": "<p>19. Almost done, but let’s differentiate our characters just a little bit. So far, we’ve instantiated objects of Player, Enemy, and NPC types, but never a base “Character” object. This is because Character is designed just to give attributes and methods to these subclasses, not exist itself. So let’s go ahead and make it abstract.</p>"
            },
            "29": {
                "actionType": "Code",
                "content": "<p>20. Making Character abstract doesn’t give us any errors, because we haven’t added any abstract methods yet. Let’s add a new abstract method that all our classes have to implement. We’ll give our characters some personality by creating a method called “introduce()’. This will be public, abstract, and void. Create this method. Remember, an abstract method is created similarly to how they are done in interfaces.</p>"
            },
            "30": {
                "actionType": "Code",
                "content": "<p>21. If you complete step 20 correctly and save, you’ll get syntax errors in your three character subclass files. Go to one of these files and mouse over the error. It will look familiar from when we were implementing interface. Have VSCode implement the method in all your files, but once it creates the stub, go into the method yourself and add a SOP that gives some context to the character. For example, the player character could say “I save villages!”, the NPC could be “I sell protective footwear!”, and the enemy could be “I mindlessly follow AI without having clear motives, while letting the player grind experience!”</p>"
            },
            "31": {
                "actionType": "Code",
                "content": "<p>22. In your SpriteGame class, create one more method, like you did for the character names and the fightables, to output each character’s introduction. Note that you already have an ArrayList with all your characters to use.</p>"
            },
            "32": {
                "actionType": "Read",
                "content": "<p>That’s all we’ll do with this. If you wanted to complete the game, you’d have to make all the methods that implement the interfaces actually do things instead of just being empty. However, this shows how you can use interfaces, inheritance, and abstract classes to set up hierarchies and relationships, and define what classes are and what classes can do. It also shows how you can use polymorphism to group objects in a way such that you can use functionality that is common to those classes, even though they are of different types.</p>"
            }
        },
        "totalParagraphs": 33
    },
    "Lesson 15 - Static & Super": {
        "Introduction": {
            "0": {
                "actionType": "",
                "content": "<p>In this lesson we round out the last couple small concepts of OOP that we’ve skipped thus far \nand do another code review of some Romi code because after this lesson you’ll understand every \nconcept that you need to, to grasp everything that goes on in the Romi code, at least from a Java \nperspective. (You will still run into WPILib methods that you might need to check the documentation on \n– but at least you’ll understand all the Java code that they’re made from.) After the code review you’ll \ndo some small desktop projects. After this lesson, the remaining lessons in the course will all be \nadvanced projects with the Romi that will give you a chance to flex your knowledge and understanding. \nThe two concepts left to cover are static and super. \n</p>"
            }
        },
        "Static": {
            "1": {
                "actionType": "Read",
                "content": "<p>One of the main concepts in object-oriented programming is that objects have state. That \nmeans there exists some object of some class, it has some variables, and cumulatively they define that \nobject. If you have multiple objects of a given class, they probably have different values in their \nvariables, thus differentiating them. If you were to access the variables of the objects directly, you \nwould get a different value depending on which object you accessed. If you were to call a method of the \nobject, you would again get a different value depending on which object you called the method for, \nbecause the variables would have different values. E.g., if in a fantasy game if you called getLevel() on an \norc, you might get a different result than if you called getLevel() on a dragon. \n</p>"
            },
            "2": {
                "actionType": "Read",
                "content": "<p>However, there are sometimes instances where a class field or method will return the same \nresult regardless of which object it came from. For example, consider the following method: \n</p>",
                "image": "<img src=\"./images/lesson15_0.png\"/>"
            },
            "3": {
                "actionType": "Read",
                "content": "<p> \nThis method could exist in any class, but no matter where it exists, or the state of any objects \nbelonging to the class where it exists, it will always return the same result for any given numbers as \ninput. Nothing else about the class it exists in, or any objects of that class, matter – it will simply add the \ntwo numbers and return the result. The state of the object that the method is being called from does not \nmatter. When a method or variable fits this description, you can use the static keyword in its signature. \nIt’s not mandatory to do so – you could remove the static keyword from the method above and the \nmethod would still function the same way. However, the static keyword grants a special ability – you can \ncall the method without instantiating an object of the class. This can be illustrated with a couple \nexamples because you’ve already used this functionality numerous times during this course. Think about \nevery time you’ve used System.out.println(). System is a class, but you’ve never declared a System \nobject. Turns out that the out portion of “System.out” refers to a static object, so you can use the \nfunctionality of System.out without declaring an object. This is handy, because it would be annoying to \ndeclare System objects every time you wanted to do something as simple as output a line of text. \n</p>"
            },
            "4": {
                "actionType": "Search",
                "content": "<p> \nAnother example is the Constants file you’ve used in your Romi code. Here are a couple lines \nfrom the ArcadeDrive method in your DriveStraight project (Lesson 11 version): \n</p>",
                "image": "<img src=\"./images/lesson15_1.png\"/>"
            },
            "5": {
                "actionType": "Search",
                "content": "<p> \nThese lines reference values from the Constants file, but you never create a Constants object. \nOpen Constants.java and you can see that these values are declared statically: \n</p>",
                "image": "<img src=\"./images/lesson15_2.png\"/>"
            },
            "6": {
                "actionType": "Read",
                "content": "<p> \nThe static declaration lets these constants be accessed anywhere without declaring a Constants \nobject. This is possible because, as static constants, they do not rely on the state of any object – they will \nalways return the specified value. \n</p>"
            },
            "7": {
                "actionType": "Search",
                "content": "<p> \nStatic works for both methods and values, as shown in the examples above. The only factor is \nthat anything declared as being static can’t rely on the state of the class in which it’s declared. Let’s look \nat a counterexample of this to demonstrate the point. Here are some lines the ArcadeDrive method \nfrom the DriveStraight project again: \n</p>",
                "image": "<img src=\"./images/lesson15_3.png\"/>",
                "more_images": "<img src=\"./images/lesson15_4.png\"/>"
            },
            "8": {
                "actionType": "Search",
                "content": "<p>Note how on lines 53, 54, 57, and 58, the method relies on turnTimer, which is a class variable \ndeclared on line 20 in Drivetrain.java. A static method can neither read nor write to such a variable, \nbecause doing either of those things requires a class state – either by reading an existing state or \ncreating a state by writing one. That could not be done without an existing Drivetrain object. Another \nexample is on line 62, arcadeDrive updates the value of targetHeading, which is another class variable. \nNeither of these operations could work without maintaining the state of these variables, so arcadeDrive \ncould never be a static method. \n</p>"
            },
            "9": {
                "actionType": "Search",
                "content": "<p>You’ve probably observed by now how class names are capitalized, like Constants, Drivetrain, \nand System, but variable names start with lowercase letters. This makes it easy to tell, for any given text \nsnippet, if it’s referring to a variable or a class itself. If you look at lines 52 and 53 in the previous image, \nyou’ll notice that “Constants” is capitalized – this is because it’s referring to the class itself. Static fields \nand methods are accessed in this manner, using the proper class name instead of a specific object. \n</p>"
            },
            "10": {
                "actionType": "Search",
                "content": "<p>Another fun example of static methods and variables in Java is the “Math” class. Anywhere in \nyour code, you can type “Math.” and see a big list of static methods and values you can use, for example \nMath.PI or Math.abs, which you’ve used before. \n</p>",
                "image": "<img src=\"./images/lesson15_5.png\"/>"
            },
            "11": {
                "actionType": "Read",
                "content": "<p>As a general rule, static values are great for declaring program-wide constants, which is literally \nwhy the Constants.java file exists in the RomiReference project. Static methods are great for helper \nmethods that perform operations on inputs. For example, you could have made a static method when \nyou did the CutPower project that would have looked something like this: \n</p>",
                "image": "<img src=\"./images/lesson15_6.png\"/>"
            },
            "12": {
                "actionType": "Search",
                "content": "<p>That may or may not have been overkill for such a simple operation, but it demonstrates the \npoint – this method could be called from anywhere in the program because it simply performs an \noperation and it doesn’t rely on the state of anything in your program. Let’s look at one final example \nfrom robot code, in Drivetrain.java: \n</p>",
                "image": "<img src=\"./images/lesson15_7.png\"/>"
            },
            "13": {
                "actionType": "Read",
                "content": "<p>These values are declared statically because they describe physical characteristics about the \nrobot. For example, line 18 is telling the code what the diameter of the Romi’s wheels is, which is used \nin calculations for how far the Romi has driven, but never changes and while it is related to the \ndrivetrain, does not rely on anything in the Drivetrain class because it’s simply a physical truth about the \nrobot.</p>"
            }
        },
        "Super": {
            "14": {
                "actionType": "Read",
                "content": "<p>Using inheritance creates a scenario where for a given class, there can be more than one version \nof a given method. One version of the method can belong to the subclass, and one can belong to its \nparent class, or “superclass”. In fact there could be many versions, as there could be a long chain of \ninherited classes, and every class in the chain could have their own version. The same situation can \nhappen with constructors – you know that a constructor gets called whenever an object is created, but, \nlooking at your project from last lesson, if an object of type “Player” is created, and Player objects are \nalso “Character” objects, which constructor gets called? \n</p>"
            },
            "15": {
                "actionType": "Read",
                "content": "<p> \nJava has default behavior to handle this situation but also gives you the ability to control what \nhappens more directly. When a method is called for an object, it will use the method defined for the \nsubclass. In a long chain, it will use the lowest-level class it can (that is, if the lowest-level class does not \nhave that method defined, it will use the direct parent’s version. If the direct parent does not have that \nmethod defined, it will use the grandparent’s, etc.) This gives you the power to override parent class \nmethods but use them as defaults if you don’t want to override them. \n</p>"
            },
            "16": {
                "actionType": "Read",
                "content": "<p> \nHowever, parent versions of methods are accessible from within a subclass by using the super \nkeyword. The super keyword is not a variable, but it almost acts like one – if you’re in a class method (go \ninto your Player class, inside a method, and try this) and you type “super.”, VSCode will pull open a \nmenu of methods that you can call, the same as if you typed the name of an object variable that has \nmethods. From super, you can find any method defined in your parent class and call it directly. \n</p>"
            },
            "17": {
                "actionType": "Code",
                "content": "<p> \nThe same syntax can be used for constructors. Every time you create an object using the “new” \nkeyword, you call a constructor. Also remember that every class has a default constructor method, even \nif you don’t define it. Remember, a “default” constructor is one that takes no parameters. When an \nobject of a child class is created, you call the child class’s constructor using the new keyword. Java will \nthen automatically call the superclass’s default, or parameterless, constructor. This is referred to as \ncalling the constructor “implicitly”. Often such a constructor does nothing so you would never notice, \nbut you can try this out. Go into your Character class from lesson 14 and add the following method:</p>",
                "image": "<img src=\"./images/lesson15_extra.png\"/>"
            },
            "18": {
                "actionType": "Code",
                "content": "<p> \nIf you run your program, you will see this printout for each of the character objects you created, \ndespite you never manually calling this constructor. Since you called your subclass constructor, and Java \nimplicitly called the superclass constructor, that means that for subclass objects, more than one \nconstructor is called. \n</p>"
            },
            "19": {
                "actionType": "Read",
                "content": "<p> \nBy default Java will call the parameterless superclass constructor. But if you have custom \nconstructors defined in your superclass and want to call a specific one, you can again use the super \nkeyword. In this case, super is the name of a method and you give it parameters directly – for example, \n“super(name, hitPoints);”. If you find that you have similar constructors among your different \nsubclasses, creating a superclass constructor and then referencing it from the subclasses can be a good \nstrategy. The call to the superclass constructor goes in the subclass constructor, which can then do other \nthings. For example, if all Character subclasses need to set the character’s name, you could create a \nCharacter superclass constructor to do that. But then maybe Enemy class objects need some additional \nwork – say, initializing a “difficultyLevel” variable. In your Enemy class constructor, you would call \nsuper(name) to set the name, and then set the difficultyLevel like normal. \n</p>"
            },
            "20": {
                "actionType": "Code",
                "content": "<div><p>1. Create a new desktop project and a class called “BasicOperations”. Then define and \nimplement the following four static methods. Each class is to take two integer parameters \nand return and integer, except for “divide” which will take two doubles and return a double. \n</p><ol><li>add()</li><li>subtract()</li><li>multiply()</li><li>divide()</li></ol></div>"
            },
            "21": {
                "actionType": "Code",
                "content": "<p>2. In your main method, call each of your newly created methods in a static fashion. That is, do \nnot create an object of the class type BasicOperations – simply call the static methods. \n</p>"
            },
            "22": {
                "actionType": "Code",
                "content": "<div><p>3. Call the following methods from the java “Math” class (e.g. double varName = \nMath.cos(10);) and output their values: \n</p><ol><li>Math.cos</li><li>Math.sin</li><li>Math.PI (this is a constant, not a method)</li><li>Math.random (read the description VSCode gives to see what this method does)</li></ol></div>"
            },
            "23": {
                "actionType": "Code",
                "content": "<p>4. In the lesson 14 exercises, you created constructors for Player, NPC, and Enemy that all \ncalled the Character.setName method. Instead of using these constructors, create a single \nconstructor in the Character class that accepts a String parameter and sets its name \nvariable. Then, in your subclasses, call this new superclass constructor. \n</p>"
            }
        },
        "totalParagraphs": 24
    },
    "Lesson 16 - Manual Drive Methods": {
        "Introduction": {
            "0": {
                "actionType": "",
                "content": "<p> \nThroughout the prior 15 lessons, you’ve learned an immense amount about the Java \nprogramming language, WPILib, and how to program robots. You’ve learned all the concepts you need \nto understand the code you see in the RomiReference project and develop your own features. Over the \nnext five lessons, the focus will shift from learning more about Java as a programming language, to \ndeveloping your skills modifying and writing code. While projects have been developed thus far with \nclear lists of steps, over the next five projects, the lessons will describe goals and outcomes instead of \nguiding you specifically on how to accomplish them. There will not be images with exact code solutions, \nso you will need to use your own skills. There will also not be solution programs provided. Feel free to \nrefer back to prior lessons and projects for both a review of concepts, and examples of how to use \ncertain features of code. We’ll step into this slowly. This lesson will still give you some specific pointers, \nbut not all of them, and starting with lesson 17 there will be very few specific pointers. At first this may \nbe difficult for you, but with time and practice you will succeed. \n</p>"
            }
        },
        "Creating Homemade Drive Methods": {
            "1": {
                "actionType": "",
                "content": "<p>So far, you’ve relied on pre-coded methods to make your robot move, specifically the \narcadeDrive method in the DifferentialDrive class, which you access through the arcadeDrive method in \nthe Drivetrain class. You’ve modified the values that are sent to this method, thereby affecting drive \nbehavior, but you’re still using this method to make the robot move. This is fine – the DifferentialDrive \nclass is pretty good for making your robot move. However, as you get more advanced, you’ll want a finer \ndegree of control over your robot, and the first step in achieving that is creating your own methods that \ndrive the robot. In this lesson you’ll create those. First, you’ll create a simple “tank drive” method and \nassociated commands, and then implement your own arcade drive. Tank drive is easier to code because \nthere is less math, whereas for arcade drive you need to convert a rotation value coming from the \njoystick into power outputs to both wheels. Thankfully you can copy this math from the pre-existing \narcadeDrive method in DifferentialDrive, but since tank drive is easier, that’s where we’ll start. \n</p>"
            },
            "2": {
                "actionType": "",
                "content": "<p> \nOne quick note – we’ve briefly discussed deadbanding, or removing joystick input that is close \nto, but not exactly equal to, zero. The DifferentialDrive class adds deadbanding by default, but as soon \nas you stop using DifferentialDrive, you won’t have deadbanding anymore. You’ll implementing \ndeadbanding yourself in the next lesson but keep in mind that your robot might have a tendency to \n“crawl” whenever it is enabled during this lesson, in particular if your controllers are old and don’t do a \ngreat job of physically re-zeroing themselves when you release the joysticks. Just watch out and don’t let \nyour robot crawl off your desk and fall. \n</p>"
            }
        },
        "Creating Tank Drive": {
            "3": {
                "actionType": "",
                "content": "<p>Tank drive gets its name from tank vehicles, and their drive setups with treads on each side. \nEach side of the tread can drive independently. Powering them both forward makes the tank move \nforward, powering them both in reverse drives the tank backward, and powering them in opposite \ndirections makes the tank spin, or if done in a controlled manner, turn. Although you have a Romi and \nnot a tank, any drivetrain that has two independently powered sides of its drivetrain can follow this \ncontrol scheme, and your Romi of course has that. (Compare this to a front-wheel drive car, where the \ndrive wheels are powered together.) \n</p>"
            },
            "4": {
                "actionType": "",
                "content": "<p> \nTank drive is easy to program because there’s basically no math required to do so. Instead of \nusing one joystick axis for robot speed and one for turning, you use one joystick axis to power the left \nside, and one to power the right side. This makes setting your motor outputs as simple as sending the \ninput from the joystick directly to the motors. Complete the following steps to create your own tank \ndrive setup: \n<ol><li>Create a new RomiReference project called “ManualDrive”.</li><li>In Drivetrain.java, comment out or delete the line where the DifferentialDrive object is declared. This will cause a syntax error later on where that object is used, and you can delete that line as \nwell. \n</li><li>Crete a public void method called “tankDrive” that accepts two doubles, one for the left power and one for the right power. \n</li><li>In the tankDrive method, simply set the outputs of the two Spark objects using their .set method. Here’s an example of a completed tankDrive method: \n</li></p>",
                "image": "<img src=\"./images/lesson16_0.png\"/>"
            },
            "5": {
                "actionType": "Code",
                "content": "<p>5.  You now have a method that will drive your robot using a tank drive setup, but it’s not be called from anywhere. Right now your drivetrain subsystem runs the ArcadeDrive command by \ndefault, which calls the arcadeDrive method in Drivetrain.java, but since you deleted the line of \ncode that told the DifferentialDrive object to drive, that arcadeDrive method no longer has any \nfunction and if you were to deploy your robot code, you would not be able to drive your robot in \nteleop. We’ll fix the arcadeDrive method when we get to the arcade drive portion of this \nproject. For now, create a new command in the commands folder called TankDrive.java.</p>"
            },
            "6": {
                "actionType": "Code",
                "content": "<p>6. Flesh out your TankDrive command. You can mostly copy the ArcadeDrive command, but change the names of the variables as appropriate. For example, you’re taking in two power \nvariables instead of a power variable and a rotation variable. That’s the only real difference.</p>"
            },
            "7": {
                "actionType": "Code",
                "content": "<p>7. With the TankDrive command completed, go to RobotContainer.java, find where you set the default command for your drivetrain, and update it to use your new TankDrive command. To do \nthis you’ll need to create a new “getTankDriveCommand()” method in RobotContainer.java. \nCreate this method. You can copy the getArcadeDriveCommand() method and rename it. Note \nthat after creating the method, you’ll still need to update the line that sets the default \ncommand, or it will still use the old getArcadeDriveCommand method.</p>"
            },
            "8": {
                "actionType": "Code",
                "content": "<p>8. At this point you could deploy and drive, but it wouldn’t control very well because you’re still using the default axes for driving. You’ve had to change the default axes (on line 95 of \nRobotContainer.java) a number of times in various projects throughout the course, and you’ll \nneed to do it again here. The only difference is that you may not want to use the same axes for \ntank drive as you did for arcade drive. If you’re using a single joystick, there is no comfortable \nway to do tank drive, so it won’t matter too much which axes you pick. But if you’re using more \nthan one joystick (either two physical sticks, or a controller with more than one joystick such as \na gamepad or Xbox controller), you’ll probably want to use the forward/backward axis of two \nseparate joysticks, with the joystick on your left controlling the left speed and the joystick on \nyour right controlling the right speed. You can figure out which axis is which by running your \ncode and using the Joysticks window in the Robot Simulation interface, as you’ve done \npreviously throughout this course. Once you figure out which joysticks to use, update the \ndefault joysticks in RobotContainer, deploy your code, and test it. You’ll now have a working \ntank drive setup!</p>"
            }
        },
        "Creating Arcade Drive": {
            "9": {
                "actionType": "",
                "content": "<div><p>Creating your own arcadeDrive method is a little bit trickier since there’s some math involved, \nbut you can copy the math from the arcadeDrive method declared on line 179 of DifferentialDrive.class. \nNote that there are multiple arcadeDrive methods in DifferentialDrive because it is an overloaded \nmethod; the one declared on line 179 is the one you want to look at. The easiest way to open this file is \nto use F12; you may have an unused import referring to this class roughly around line 10 of \nDrivetrain.java (it became unused when you deleted the DifferentialDrive object declaration), but if you \ndon’t, you can declare another such object, F12 into the class, and then undo the change you made to \ndeclare the object. Either way, once you get into DifferentialDrive, the lines you’ll want to copy are 199 \nthrough 222. We won’t discuss exactly how these lines work, but the general gist is that they do a little \nbit of math to figure out how much power to send to each wheel, based on the speed of the robot and \nhow much turning power to apply. The part you need to recognize is that two important variables and \ncreated and initialized by this code: leftMotorOutput and rightMotorOutput. These are the variables you \nwill need to send to the motor outputs. One last thing – since your motors face in opposite directions \nthe way they are physically mounted on the Romi, one of them needs to run in reverse, or your robot will \nspin in circles when you tell it to go forward. In this case, you’ll want the motor that runs in reverse to be \nthe right motor. To make it run in reverse, simply multiply its output by -1 before sending it to the \nmotor. Here are a list of steps to complete creating your own arcade drive setup: </p><ol><li>Open DifferentialDrive.class as described above, and copy lines 199 through lines 222.</li><li>Paste the copied lines into your arcadeDrive method in Drivetrain.java.</li><li>You’ll have a couple mismatched variable names after pasting the code (for example, xaxisSpeed vs. xSpeed.) It doesn’t matter which of these names you choose, but fix the mismatches so you \nno longer have any syntax errors. \n</li><li>At the bottom of your method, after all the code you pasted in, update the value of rightMotorOutput by multiplying it by -1. \n</li><li>Set the left and right motors to their respective outputs.</li><li>Test your code and ensure that arcade drive works. When it does, you’re done with this project!</li></ol><p>Here is an example of a completed Drivetrain.arcadeDrive method: \n</p></div>",
                "image": "<img src=\"./images/lesson16_1.png\"/>"
            }
        },
        "totalParagraphs": 10
    },
    "Lesson 17 - Deadbanding & Turn Scaling": {
        "Introduction": {
            "0": {
                "actionType": "Read",
                "content": "<p><i>Reminder: from lesson 16 onwards, the projects are aimed for you to do with less guidance, \nfewer or no direct steps, and without solution projects provided.</i></p>"
            },
            "1": {
                "actionType": "Read",
                "content": "<p> \nIn lesson 9, we briefly talked about the concept of deadbanding, or creating a zone of input from \nthe joysticks which register as zero, even if the input is not literally zero. You may recall that this can be \nuseful because the joysticks don’t physically return to a perfect zero and might register some value like \n.05 instead when at rest. If you don’t remember much about deadbanding, you’ll want to review lesson \n9. In this project, you’ll add code to your arcadeDrive method from lesson 16 to create a deadband on \nthe user input. You’ll also scale the rotation value based on the magnitude of the speed value. That is \nsimilar to what you did when you implemented cut power mode, except instead of a boolean value of \neither cutting the power or not, you’ll scale the turning power dynamically based on the speed. For \nexample, if the speed is 0, you would not want to scale down the turning at all, but if the speed was 1, \nyou might want to scale it down by some amount, say 50%. In that case, you’d be scaling down the \nturning power by .5 multiplied by the speed value. So a speed value of 1 would be a 50% reduction in \nturning power, a speed value of .8 would be a 40% reduction in turning power, a speed value of .2 would \nbe a 10% reduction in turning power, etc. \n</p>"
            }
        },
        "Deadbanding": {
            "2": {
                "actionType": "Code",
                "content": "<p>To complete the deadbanding portion of this project, create a method in Drivetrain.java called \n“applyDeadband” that accepts a double representing the input value, and returns a double that is the \ninput value after deadbanding is applied. Create a value in Constants.java that specifies what the \nminimum threshold for input from the joysticks needs to be in order to pass the deadband filter. A \ndecent first guess might be .1, but you’ll have to determine this for yourself based on the joysticks \nyou’re working with. Then, your method simply has to check if the magnitude of the input exceeds the \ndeadband threshold, or not. If it does, you can simply return the input. If it does not, you return 0. Make \nsure your applyDeadband method returns the input with the same sign that was passed into it – that is, \nif a positive value was passed in, a positive value (or 0) should be returned, and if a negative value was \npassed in, a negative value (or 0) should be returned. When your method is done, go back to your \narcadeDrive method and pass your input values to your new method, and update their values to \nwhatever the method returns. That’s a mouthful but this is very simple, because you can update the \nvalue of a variable, and pass that variable into a method, all in one line of code. Your lines that call \napplyDeadband should look like this: \n</p>",
                "image": "<img src=\"./images/lesson17_0.png\"/>"
            }
        },
        "Turn Scaling": {
            "3": {
                "actionType": "Code",
                "content": "<div><p>To complete the turn scaling portion of this project, create a method in Drivetrain.java called \napplyTurnScaling that takes two doubles, one for speed, and one for rotation, and returns a double that \nis the scaled turning value. You can update your zaxisRotate value in arcadeDrive the same way you \nupdated it for the deadbanding portion, except by calling applyTurnScaling in your drive method. Inside \nthe applyTurnScaling method, you need to figure out how much to reduce the turning, which you can do \nby multiplying the speed value by a new Constants.java value you’ll create that represents how much \nyou want to scale the turning down, for example .5 if you want to scale the turning down by 50% at max \nspeed as explained in the example at the start of this lesson. This represents the percent you want to \nreduce the turn power by – for example, if your speed is .8 and you’re using .5 as your constant, you’d \nwant to scale down the turning by 40%. \nOnce you’ve determined your percentage reduction in turning, you can subtract that number from 1 to \ncreate a turn scaling coefficient. For example – let’s again say the speed is .8 and the scale factor is .5. \nThen, .8 * .5 = .4, which is your turn reduction percentage. 1 - .4 = .6, so .6 is your turn scaling \ncoefficient. The last step is to multiply your turn input value by your coefficient to determine the final \nturning value. Here’s a full example, written out in English and shown with numbers: \n</p><ol><li>Multiply by the speed by the Constants.java turn scaling value, and save this value to a variable called “turnReductionPercent”. For the example, assume the speed is .8 and the turn scaling \nvalue is .5. --> .8 * .5 = .4</li><li>Subtract the turnReductionPercent variable from 1, and save this to a variable called “turnCoefficient”. --> 1 - .4 = .6</li><li>Scale (multiply) the original turn value by the turnCoefficient. Assume the original turn value is 1. --> 1 * .6 = .6</li><li>Return the final result, in this case .6.</li></ol></div"
            }
        },
        "Testing": {
            "4": {
                "actionType": "Robot",
                "content": "<p>Once you’ve created your two methods and utilized them in your arcadeDrive method, make \nsure to test them by driving the Romi around. The deadband method can be tested by trying to drive \nyour robot while looking closely at the Robot Simulation interface. Pick the Romi up and hold it in your \nhand so there is no friction on the wheels, and slowly start pressing on the joystick while looking at the \njoystick values on the interface. The wheels should start spinning right as you cross the deadband \nthreshold. \n</p>"
            },
            "5": {
                "actionType": "Robot",
                "content": "<p> \nTo test turn scaling, put the Romi back down and start spinning it in circles without giving it any \nforward/backward speed. Then start giving it forward/backward speed. You should see the rate of \nturning decline as you give it more speed. You can increase the value of the turn scaling constant in \nConstants.java to see a more drastic effect, which is useful for testing. \n</p>"
            }
        },
        "totalParagraphs": 6
    },
    "Lesson 18 - Exponential & Linear Control": {
        "Exponential vs. Linear Control": {
            "0": {
                "actionType": "Read",
                "content": "<p>This lesson will build upon lessons 16 and 17 by further enhancing your arcadeDrive method. \nYou’ll change it from using a linear mapping of the joystick value to the motor outputs, to an exponential \none, and compare how the drive characteristics feel with each control scheme. \n</p>"
            },
            "1": {
                "actionType": "Read",
                "content": "<p> \nA linear mapping of the joystick values is straightforward – a .25 value on the joystick translates \nto .25 motor output, .5 to .5, and so forth. This makes sense, but it isn’t necessarily the best way to \ncontrol a robot. Often, when the driver wants to go fast, they want to go fast – they’re probably going to \napply full power to the robot. It’s often rare that a driver will want to drive at, say, 80% power. However, \nwhen they want to go slowly, they might want to go at different slow speeds. For example, they might \nwant to barely move, or cruise but slowly, or move just slow enough to maintain full turning control. \nExample desired motor outputs in these cases might be .25, .33, or .5. However, for a human driver, it \ncan be difficult to physically create the difference these values on a joystick, since the distance between \n.25 and .33 on a joystick is fairly small. \n</p>"
            },
            "2": {
                "actionType": "Read",
                "content": "<p> \nWith an exponential mapping, the input from the joystick is raised to some power, typically two \n(or in other words, squared) before being sent to the motors. So a value of .1 would become .01, .5 \nwould become .25, a value of .75 would become .5625, and a value of 1 would stay 1. The fact that 1 still \ncorresponds to 1 is important, so that you don’t lose any of your maximum output range. \n</p>"
            },
            "3": {
                "actionType": "Read",
                "content": "<p>When you square the inputs, a much larger portion of the physical joystick range corresponds to \nthe smaller range of possible outputs. For example, with linear control, the physical range between 0 \nand .5 is, of course, 50% of the joystick’s travel distance in a single direction. (Ignore deadbanding for \nthis example.) With exponential control, a value of .707 corresponds to 50% (.707^2 = .5), so you have \nalmost 71% of the joystick’s travel distance covering the same range. \n</p>"
            },
            "4": {
                "actionType": "Search",
                "content": "<p>Exponential control is not necessarily “better” than linear control, but many drivers do feel that \nit improves robot handling when they try it. The Romi is fairly small, low speed, and easy to control \neither way, but you can make the decision for yourself after you try both out. The Romi actually uses \nexponential drive by default but you can change this by changing the “true” value on line 167 of \nDifferentialDrive.class (accessible by F12’ing on the “DifferentialDrive” class found in the class fields of \nDrivetrain.java) to false, as this variable corresponds to a the boolean parameter “squareInputs” in the \narcadeDrive method declared on line 179 of DifferentialDrive.class and does exactly what is described in \nthe prior section. Or, you can skip that, implement it yourself, and try it out after doing so, because \nregardless of which one you prefer you’ll implement both in this project. \n</p>"
            },
            "5": {
                "actionType": "Search",
                "content": "<p>The arcadeDrive method declared on line 179 of DifferentialDrive.class has all the logic that \nmakes the robot drive and turn, so you can use that as a reference as you complete this project. Note \nthat there are multiple arcadeDrive methods in this file because of overloading, but the one declared on \nline 179 is where the important logic is. Lines 204 through 222 handle combining the rotation value with \nthe speed value to create the net values sent to the motors, and lines 224-226 handle setting the \nmotors. (Line 225 multiplies one side by -1 if necessary, because one motor is functionally driving in \nreverse, because the motors are physically pointed in different directions on the robot.)</p>"
            }
        },
        "Doing the Project": {
            "6": {
                "actionType": "Code",
                "content": "<p>For your project, implement your own arcadeDriveCustom method in Drivetrain.java. You’ll \nneed to copy some of the code mentioned above unless you want to do the math yourself. In theory you \ncould copy the whole method if you want, but even if you do this you’ll still have some work to do \nbecause this method exists within the DifferentialDrive class and you’re going to make your method in \nDrivetrain.java. To start, comment out this line in Drivetrain.java: \n</p>",
                "image": "<img src=\"./images/lesson18_0.png\"/>"
            },
            "7": {
                "actionType": "Code",
                "content": "<p>This will give you a syntax error because you won’t have an m_diffDrive object anymore:\n</p>",
                "image": "<img src=\"./images/lesson18_1.png\"/>"
            },
            "8": {
                "actionType": "Code",
                "content": "<p>Instead of calling the arcadeDrive method of the DifferentialDrive class, you’ll replace the line \nthat now gives a syntax error with a call to your newly created method. The goal will be to do that and \nhave your robot still drive. Here’s what your new method call should look like. Of course, if you type this \nin right away you’ll get a syntax error, but the project is to create this method and make it drive your \nrobot. \n</p>",
                "image": "<img src=\"./images/lesson18_2.png\"/>"
            }
        },
        "A Few Pointers": {
            "9": {
                "actionType": "Code",
                "content": "<ul><li>The hardest part is getting started so here are a few pointers to help you out.</li><li>You can start by commenting out the lines as shown above and replacing them with the \narcadeDriveCustom method call. As soon as you define that method, your syntax errors will go \naway, but your robot won’t drive anymore until you fill in your new method with code.</li><li>The Spark objects declared in Drivetrain.java have “set(double speed)” methods that will send \noutput to the motors, so for example you could use the following lines to set them to full power: </li></p>",
                "image": "<img src=\"./images/lesson18_3.png\"/>"
            },
            "10": {
                "actionType": "Code",
                "content": "<ul><li>Since you need to implement both linear and exponential control, it’s probably easiest to start with linear control and get your robot moving before tackling exponential control.</li><li>An easy test to confirm that you’re reading in your input the right way, and setting output the right way, is setting the left motor to the speed value and the right motor to the turn value. This won’t be “arcade drive” anymore, it will be “tank drive”, so feel free to try driving your robot like that. It will work well on an Xbox controller but not a single joystick. It will still work on a joystick, it just won’t be comfortable to drive. Also, the variable names “xaxisSpeed” and “zaxisRotate” would become incorrect, as the values would represent “leftSpeed” and “rightSpeed’. But, it will confirm for you that you’re properly getting the joystick values and outputting them to the motors. You don’t have to do this, it’s just an option for getting starting.</li><li>As stated, you can copy most or all of the arcadeDrive method from DifferentialDrive if you want. But you don’t need all of it to complete the project, as that method has a lot of additional stuff. All you need to do is do the math to create linear and exponential drives. As mentioned before, lines 204-222 are the lines that combine the speed and rotation variables into left and right motor output values, which you would then use in your m_left and m_rightMotor.set() methods.</li></ul>"
            },
            "11": {
                "actionType": "Code",
                "content": "<ul><li>You don’t need to worry about any of the code from the DriveStraight project in this project, although you could implement that if you want.</li><li>When you square inputs for the exponential control mode, make sure you don’t turn negative numbers into positive numbers. Remember, 1 squared equals one, but -1 squared also equals one. There are a couple different ways to account for this. You can use if statements to multiple negative values by -1 after you square them, but a better way is demonstrated on lines 195 and 196 of DifferentialClass.java.</li></ul>"
            }
        },
        "totalParagraphs": 12
    },
    "Lesson 19 - Parallel Command Groups": {
        "Introduction": {
            "0": {
                "actionType": "Read",
                "content": "<p> \nIn lesson 10 you learned about commands and command groups and created some autonomous \nroutines, by modifying a sequential command group, where commands are run in sequence, with the \nnext one starting automatically after the last one finishes. In this lesson you’ll utilize parallel command \ngroups, where multiple commands can run at the same time across different subsystems. You may want \nto open lesson 10 for review as you complete this project. \n</p>"
            },
            "1": {
                "actionType": "Read",
                "content": "<p> \nIn the RomiReference project there are two subsystems, the drivetrain and the on-board IO \nsystem, which, among other capabilities, has LED lights that you’ve used a couple times throughout this \ncourse. You’ll use these two subsystems in concert to create a parallel command group that runs \ncommands on both systems. \n</p>"
            }
        },
        "Parallel Command Groups": {
            "2": {
                "actionType": "Code",
                "content": "<p>Parallel command groups (PCGs) are fundamentally pretty similar to sequential command \ngroups. The main difference is that the commands you add to the group using the addCommands \nmethod will all begin at the same time. There are a couple different types of PCGs, which you can see \nbrief descriptions of in the dropdown interface you see when you create a new command. To get \nstarted, create a new RomiReference project called “ParallelLights”, right click on the commands folder, \nand choose to create a new command. Type “parallel” into the filter bar and you’ll see three options: \n</p>",
                "image": "<img src=\"./images/lesson19_0.png\"/>"
            },
            "3": {
                "actionType": "Code",
                "content": "<p> \nThe simplest type of PCG is the default “ParallelCommandGroup”. With this type, the command \ngroup will finish when all of the commands in it finish. With the Race group, the command will end as \nsoon as any command finishes, and with the Deadline group, you can specify a specific command, and \nwhen that command finishes, the group will finish. Go ahead and create a PCG; it doesn’t matter what \nyou name it because you’ll delete it and re-create it later when you do the project. \n</p>"
            }
        },
        "Combining Command Types": {
            "4": {
                "actionType": "Search",
                "content": "<p>Now that you understand class hierarchies in Java, let’s take a moment to reason about \ncommand groups and commands. In your newly created PCG, on the line declaring the class, you’ll see \nthat it extends ParallelCommandGroup, meaning that it is a child class of the parent class, \nParallelCommandGroup. Example: \n</p>",
                "image": "<img src=\"./images/lesson19_1.png\"/>"
            },
            "5": {
                "actionType": "Search",
                "content": "<p> \nIf you F12 into ParallelCommandGroup, you’ll see that this, in turn, extends \nCommandGroupBase: \n</p>",
                "image": "<img src=\"./images/lesson19_2.png\"/>"
            },
            "6": {
                "actionType": "Search",
                "content": "<p> \nBoth the ParallelCommandGroup and SequentialCommandGroup classes extend \nCommandGroupBase, meaning that both of these types of objects are also CommandGroupBase objects. \nIf you F12 into CommandGroupBase, you’ll that it extends CommandBase and implements Command. \nImplementing Command is the key thing to notice here. Anything that implements Command can be \nused as a Command, because implementing Command tells Java that the class has the critical Command \nmethods such as initialize, execute, etc. Since all the different types of command groups extend \nCommandBase, and CommandBase implements Command, all the command groups also implement \nCommand, meaning that all command groups can also function as Commands. This is important because \nthis means that when you’re adding a command to a command group, you can add a command group \ninstead of a basic command. \n</p>"
            },
            "7": {
                "actionType": "Read",
                "content": "<p>Let’s look at an example. There is a lot of text to take in here, so feel free to read this a couple \ntimes until you wrap your head around it. The RomiReference project has a command group called \n“AutonomousDistance”, which you’ve worked with in the past. It has four sub-commands that are \nadded using the addCommands method. You could add additional commands to it, and those \ncommands could themselves be command groups. This lets you combine various command types to \ncreate complex behaviors. For example, you could create a ParallelCommandGroup that turns lights on \nthe OnBoardIO to turn on, while telling the Drivetrain to drive. You could then add that command to the \nsequential AutonomousDistance command group. Then as AutonomousDistance runs, it will start going \nthrough its commands in sequence. When it gets to your parallel command, it will run all the sub-\ncommands of your parallel command. When all of those sub-commands finish, it will resume its original \nsequence. \n</p>"
            },
            "8": {
                "actionType": "Read",
                "content": "<p>The combination of parallel commands, sequential commands, and sub-commands gives you \nvery granular control over all the subsystems on your Romi and lets you easily build complex \nautonomous modes, once the commands themselves have been coded. It lets you re-use your base \ncommands in different orders and sequences to create different autonomous modes. Mastering parallel \nand sequential commands, and how to combine them, is an important skill. It also takes a bit of practice \nso it’s time for you to start getting that practice with the project. \n</p>"
            }
        },
        "Project – AutonomousDistanceWithLights": {
            "9": {
                "actionType": "Read",
                "content": "<div><p>For the project you’ll implement the example described above. The goal is to create a sequential \ncommand group that mimics the behavior of the pre-existing AutonomousDistance command group, but \nreplace the sub-commands in AutonomousDistance with ParallelCommandGroup commands that both \ndo the action the original sub-command did (either driving or turning), and also turn the on-board IO \nLED lights on or off. For this project, you can use the green and red LEDs on the Romi. You can refer back \nto lesson 3 to see how to create a command to turn the lights on and off. The final sequence of events \nshould be as follows: \n</p><ol><li>The Romi drives forward ten inches while turning its lights off.</li><li>The Romi turns its lights on while turning 180 degrees.</li><li>The Romi turns its lights off while once again driving ten inches (repeating step 1.)</li><li>The Romi turns its lights on while turning 180 degrees (repeating step 2.)</li><li>The Romi turns its lights off.</li></ol></div>"
            },
            "10": {
                "actionType": "Read",
                "content": "<p>Steps 1 through 4 will be parallel command groups. Step 5 is a basic command, not a group. The five \nsteps combine to form a sequential command group. When you’re done, your autonomous mode \nshould drive ten inches, turn the lights on while turning, turn the lights off while driving back, turn the \nlights on while turning again, and then turn the lights off and stop. Here are some steps you can take to \ndo this project...</p>"
            },
            "11": {
                "actionType": "Code",
                "content": "<p>1. Create and implement two commands, TurnLedsOn.java and TurnLedsOff.java. Again, lesson \n3 has an example of how to do this. Use the red and green LEDs. \n</p>"
            },
            "12": {
                "actionType": "Code",
                "content": "<p>2. Create a new sequential command group called AutonomousDistanceWithLights.java that \nwill replace AutonomousDistance.java. \n</p>"
            },
            "13": {
                "actionType": "Code",
                "content": "<p>3. Update RobotContainer.java to use your new command group as the default autonomous \ncommand (you can ctrl+f “AutonomousDistance” to see where the default autonomous \ncommand is specified.) \n</p>"
            },
            "14": {
                "actionType": "Code",
                "content": "<p>4. Create two parallel command groups that you’ll use as replacements for the old driving and \nturning commands. You can call these “DriveDistanceAndTurnOffLights” and \n“TurnDegreesAndTurnOnLights” respectively. \n</p>"
            },
            "15": {
                "actionType": "Code",
                "content": "<p>5. Implement your two commands by adding their sub-commands. In this case the sub-\ncommands will be the old methods they’re replacing (DriveDistance and TurnDegrees, \nrespectively) plus the correct command that turns the LEDs on or off. You’ll need to pass in \nthe right subsystems (Drivetrain and OnBoardIO) to your command groups and sub-\ncommands. \n</p>"
            },
            "16": {
                "actionType": "Code",
                "content": "<p>6. Now that all your commands are created, go back to your new sequential command group, \nAutonomousDistanceWithLights, and add all the commands that it needs to complete the \nroutine. \n</p>"
            },
            "17": {
                "actionType": "Code",
                "content": "<p>7. Before you run your program, you’ll need to specify that the LEDs should function as output, \njust like you did in prior lessons where you used the LEDs. You can find the line where this is \ndone in RobotContainer.java by ctrl+f’ing “ChannelMode.”. Update the two ChannelModes \nto ChannelMode.OUTPUT. Example: \n</p>",
                "image": "<img src=\"./images/lesson19_3.png\"/>"
            },
            "18": {
                "actionType": "Robot",
                "content": "<p>8. Once you’ve completed all these steps, you’re ready to run and test your autonomous \nroutine! \n</p>"
            }
        },
        "totalParagraphs": 19
    },
    "Lesson 20 - Integrating Commands In Teleop": {
        "Introduction": {
            "0": {
                "actionType": "Read",
                "content": "<p> \nYou’ve made it through 19 lessons of Romi programming and there’s only one lesson to go! In \nthis lesson, we’ll combine a lot of the concepts you’ve learned over the last few months into a single \nproject. There isn’t much new content to learn here, but it will take you some time to piece together all \nthe different pieces of the project from prior projects and make them work seamlessly together. \n</p>"
            }
        },
        "Issuing Commands in Teleop": {
            "1": {
                "actionType": "Read",
                "content": "<p>You learned how to bind a command to a button on the joystick in teleoperated mode in lesson \n3, but the commands we used there acted on the on-board IO subsystem and not the drivetrain. One \ncapability you have that can be useful is to bind commands that act upon your drivetrain to buttons in \nteleop. This lets your robot automatically perform actions for you, instead of forcing you as a driver to \ndo them yourself. If you do this, while the command is running, you will lose control of the robot, \nbecause as soon as your command starts running, it will interrupt the default command that the \ndrivetrain is running. When your command finishes, the drivetrain will resume running its default \ncommand, which is your drive code, and you’ll re-gain control. As a general rule this is not a problem, \nbut you do need to be careful not to issue any commands that take longer than expected or don’t end \nproperly, or you could lose control of your robot. This also means you need to be ready to disable your \nrobot all the time while testing so it doesn’t accidentally drive away from you or fall off your desk onto \nthe floor. \n</p>"
            },
            "2": {
                "actionType": "Read",
                "content": "<p> \nIn lesson 3 you used the “whenActive” and “whenInactive” methods of the JoystickButton class \nto bind commands to run while the button was held down, or not held down. Sometimes you want \ncommands to run a single time when the button is pressed. For that, there is the “whenPressed” \nmethod. Here’s an example of using the whenPressed method to bind the built-in TurnDegrees \ncommand to a button press in RobotContainer: \n</p>",
                "image": "<img src=\"./images/lesson20_0.png\"/>"
            },
            "3": {
                "actionType": "Read",
                "content": "<p> \nThis code will make the robot turn 180 degrees whenever you press the button. You will not be \nable to drive the robot while it is turning but will regain control as soon as it finishes. You can test this \nout for yourself in a RomiReference project by copying the code above (you’ll need to import the \nTurnDegrees command using the lightbulb.) Some examples of useful commands you might bind to \nbuttons for teleop would be to turn left or right a fixed number of degrees, or to turn to a known \norientation. Say you were completing a timed challenge that involved a series of 45 degree turns. You \ncould certainly complete the challenge manually by controlling the robot, but if you bound a button to \nturning 45 degrees, you could complete it faster because your code would automatically turn the right \namount. Another example might be driving a fixed distance – say you were supposed to move back and \nforth between two points exactly 20 inches apart. Why force yourself to do all the work when you could \njust bind that to a button? As you spend more time writing code and playing with robots, you’ll find \nmore examples of things you can automate for yourself. \n</p>"
            }
        },
        "Project – Automating Teleop": {
            "4": {
                "actionType": "Read",
                "content": "<p>For the final project of the course, you’ll combine what you’ve learned and coded in prior \nprojects into a single program. Build off your code from projects 16-18, and create a program that does \nthe following... </p>"
            },
            "5": {
                "actionType": "Code",
                "content": "<div><p>• Has four different functions bound to buttons in teleoperated mode:</p><ul><li>One turns the robot left 90 degrees</li><li>One turns the robot right 90 degrees</li><li>One turns the robot around (180 degrees)</li><li>One returns the robot to its starting orientation (the orientation it was in when the program began running.)</li></ul></div>"
            },
            "6": {
                "actionType": "Code",
                "content": "<p>• Uses your custom arcadeDrive code to drive while not executing one of the functions in the prior bullet point.</p>"
            },
            "7": {
                "actionType": "Code",
                "content": "<p>• Has drive straight code implemented and passes the “tray test” where you rotate the robot around and it maintains its orientation.</p>"
            },
            "8": {
                "actionType": "Code",
                "content": "<p>• Does not automatically revert to a prior orientation after you execute one of the button press commands. That means you will need to update the target heading while these commands are running, or at the very least when they finish running.</p>"
            },
            "9": {
                "actionType": "Code",
                "content": "<p>• Successfully passes off control between the default drive command and the button-issued commands. You can test this by driving the robot forward at a slow speed, confirming that it’s behaving as expected, and then issuing a button command but still attempting to drive forward at slow speed while the button-issued command is running. The robot should complete the button-issued command instead of driving forward, and then immediately resume driving forward after the button-issued command is completed.</p>"
            },
            "10": {
                "actionType": "Read",
                "content": "<p>Once you’ve implemented and tested all these features, congratulations, you have finished the course! You’ve gained a lot of knowledge and developed some strong skills. This course is meant to be a challenge, so even if you found these projects difficult, do not worry – as you continue to gain practice, you will continue to increase your understanding, you’ll be able to write code faster, and you’ll gain confidence in your abilities. If you enjoyed working with the Romi, the next step for you would be to find a local FIRST team at your school or in your community competing in either FIRST Robotics Competition or FIRST Tech Challenge. Another step would be to continue learning Java and to take the AP Computer Science exam to get college credit. Software programming takes time to learn, but you are well on your way and if you continue your learning you will find it to be a challenging, profitable, and most importantly fulfilling skill to master.</p>"
            }
        },
        "totalParagraphs": 11
    }
}